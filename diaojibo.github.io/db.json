{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/Staticfile","path":"Staticfile","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/profile.jpg","path":"images/profile.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1458391397109},{"_id":"source/favicon.ico","hash":"96755b44d24cf7dd57d460b8b72d2d5685737160","modified":1458021447144},{"_id":"themes/next/.bowerrc","hash":"20038353db532b4c40625419d396da7359f89cbe","modified":1457946554465},{"_id":"source/CNAME","hash":"43929ad14a150f8d53c881bf1dbf7784a1880bae","modified":1457966880055},{"_id":"themes/next/.gitignore","hash":"63d003fa46cf9665b4dab1786f9dc694812a5a79","modified":1457946554466},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1457946554467},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1457946554465},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1457946554466},{"_id":"themes/next/.javascript_ignore","hash":"beb0b95736650284ceb712a162cc033847a83cd3","modified":1457946554466},{"_id":"themes/next/_config.yml","hash":"8d91167f17d3575a29fb95981b06acd33028855e","modified":1458022069609},{"_id":"themes/next/README.md","hash":"06aaf1241e9e1619956c86d8b1397a643840a9d1","modified":1457946554467},{"_id":"themes/next/gulpfile.coffee","hash":"0494704f9e1ac8f63b9bd2791c443ffbf6091df3","modified":1457946554469},{"_id":"themes/next/package.json","hash":"afc2cbda2fe4643808c151135d5528267ee634c4","modified":1457946554494},{"_id":"themes/next/README.en.md","hash":"fa31bbc6dd8778b8dee469740c92b3b5b59702af","modified":1457946554467},{"_id":"themes/next/bower.json","hash":"93adc30dab22314f3757c3b6d3c13771de994b08","modified":1457946554468},{"_id":"source/_posts/20151226-01.md","hash":"6102ac60cb0f1b37cbc0f18b57a9f3c2d8471849","modified":1458125104792},{"_id":"source/_posts/20160125-01.md","hash":"a58ead7bf899d968a4f1683e4b39711d2adc6c9a","modified":1458125114647},{"_id":"source/_posts/20160129-01.md","hash":"39a3f02750da88f8b836ec8121690e489aa4c6ae","modified":1458133853678},{"_id":"source/_posts/20160205-01.md","hash":"de09466fc81474f4779988050c7424eb5b977d69","modified":1458275670436},{"_id":"source/_posts/20160207-01.md","hash":"090b9d47ebb3343fba580b46a1335c1e97a33e8f","modified":1458397373704},{"_id":"source/_posts/20160323-01.md","hash":"2fa0a4f0cbadc306b6e779a36f4c5124d6eb847f","modified":1458735518456},{"_id":"source/_posts/20160324-03.md","hash":"2ddb05f74ed1537f90910e2dd7eadb104ffde8c4","modified":1458830477164},{"_id":"source/_posts/20160324-01.md","hash":"4b05cb237bc5f962ce750076b453d58a76598456","modified":1458829198082},{"_id":"source/_posts/20160408-01.md","hash":"0587e81996cf747b48082cbe63d067b63a55f78c","modified":1460132901177},{"_id":"source/_posts/20160409-01.md","hash":"d08ebd3c2e7cc2f29ac2b10d70620887e5460166","modified":1460730148703},{"_id":"source/_posts/20160324-02.md","hash":"416dc1badb9c296675a5abfd8a33eed0e639b852","modified":1459255186874},{"_id":"source/_posts/20160418-01.md","hash":"d6e7f600465f2266fb35d72476b907e509ed8281","modified":1460947570716},{"_id":"source/_posts/20160417-01.md","hash":"1e6514548d70154b5cfd723d1782d009b5f96253","modified":1460883068209},{"_id":"source/_posts/20160423-01.md","hash":"0a22b28a72b1d88ded6a11dc8b75365191bf9e00","modified":1461930293909},{"_id":"source/about/index.md","hash":"74ba4cfca107e7c522d61599f976118af3dbae4d","modified":1458008969668},{"_id":"source/_posts/20160416-01.md","hash":"e29c2240016118954645f65a9d7e4d1958cea6f5","modified":1460812575689},{"_id":"source/_posts/20160418-02.md","hash":"36c5c5e2b64986538ad971d52f0c70ceae9174c8","modified":1460953134835},{"_id":"source/categories/index.md","hash":"733d77410f4b770dbaa01f4da57ce283d29c91cf","modified":1458019701243},{"_id":"source/_posts/20160328-01.md","hash":"836f21f4aa70b878d8b4ec6f9e7445fb9646a066","modified":1459253405453},{"_id":"source/tags/index.md","hash":"096f9de11c6220e2f5271699227f6c2a9690ffac","modified":1458009396317},{"_id":"source/_posts/20160415-01.md","hash":"86d3d7e286ac509b3b2f52dbbf0c5ef1d9ee0d27","modified":1460740490647},{"_id":"themes/next/layout/archive.swig","hash":"b867a08f6b43de8b5d700c84b943df55917407ae","modified":1457946554491},{"_id":"themes/next/layout/category.swig","hash":"58cf08388901f7549b1fca95548b2c79173aa840","modified":1457946554491},{"_id":"source/images/profile.jpg","hash":"541dfe115b7ed973d0d39bfbe63ad2d3dd914033","modified":1457924727475},{"_id":"themes/next/layout/index.swig","hash":"e5b52e04296203262a400e8e36ae12426d31fd5b","modified":1457946554492},{"_id":"themes/next/scripts/merge-configs.js","hash":"f8cde6953939802f92da5b7a2458c6c539e9be69","modified":1457946554494},{"_id":"themes/next/layout/_layout.swig","hash":"1b157843c811ffd0e865093586f0b6f172b73018","modified":1457946554474},{"_id":"themes/next/layout/page.swig","hash":"a91e3fd7aef26e8a02e339e3372801c517f400cf","modified":1457946554492},{"_id":"themes/next/layout/post.swig","hash":"b8334c479840b7724638eec71971cbd8512ae58d","modified":1457946554493},{"_id":"themes/next/layout/tag.swig","hash":"6f764ea3ab11eeb7c530df45528d449b14f5dc62","modified":1457946554493},{"_id":"source/_posts/project_learning.md","hash":"a222b7d434c09b06a2b1cf535c6cb79e34186ea2","modified":1458576169815},{"_id":"themes/next/test/.jshintrc","hash":"1dae9d1cf7df1ae6d5c5efd6cffb949e9b8dcebb","modified":1457946554591},{"_id":"themes/next/.git/config","hash":"340cff4364d9733a32042fdb93097c334a781c93","modified":1457946554430},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1457946540736},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1457946554424},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1457946554592},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1457946554591},{"_id":"themes/next/.git/packed-refs","hash":"cb28a1bf00dd40c9546610158957262da930aa88","modified":1457946554419},{"_id":"themes/next/languages/de.yml","hash":"4c3ffeb0d214c807a226dd98214958cb5483df1c","modified":1457946554469},{"_id":"themes/next/languages/default.yml","hash":"d2f6784b9c6567b64e58736e36025dbf96d863d4","modified":1457946554470},{"_id":"themes/next/languages/en.yml","hash":"df81ab6b1cf3c88ed053d3766381cd12eb659fe3","modified":1457946554470},{"_id":"themes/next/languages/ja.yml","hash":"e594aa42a33c489e4a65065659a01bb76c3c0cb5","modified":1457946554471},{"_id":"themes/next/languages/fr-FR.yml","hash":"d8a40fe025fad6f42df0cf16d4be2d513769b062","modified":1457946554471},{"_id":"themes/next/languages/zh-Hans.yml","hash":"23b45e77c1846c9457b98c745a60a9461678c389","modified":1457946554472},{"_id":"themes/next/.git/index","hash":"beb2a7e24a35fff6844d7a6a47efcfb54f2af426","modified":1460129750084},{"_id":"themes/next/languages/zh-tw.yml","hash":"04479b419c72b71fd34046f3fc33ebda4fe8de84","modified":1457946554473},{"_id":"themes/next/languages/zh-hk.yml","hash":"88e603eb0f3fd25c35bb37bd30372fd77bba7c46","modified":1457946554473},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1457946554531},{"_id":"themes/next/languages/pt.yml","hash":"4c64594f477905d5d2d9ca2422f03175b7b0c617","modified":1457946554471},{"_id":"themes/next/languages/ru.yml","hash":"c3aedb94decf05a301662afc3398ab563dd9995a","modified":1457946554472},{"_id":"source/_posts/20160323-01/example.jpg","hash":"9e72a1f8b6d0577ebe0fb190adfc46d3d29d4076","modified":1458735330339},{"_id":"source/_posts/20160415-01/classloader.jpg","hash":"cc00f5a79e04b7f017c329b1165e67d3cccd54c0","modified":1460740254775},{"_id":"source/_posts/20160408-01/memory.jpg","hash":"7d19c0a904c4d127e1a0b7a23ccf85db17ede9bc","modified":1460125530694},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1457946554495},{"_id":"themes/next/scripts/tags/full-image.js","hash":"86194a05a8c6499de0b2aaa525d6de135778c0ae","modified":1457946554496},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1457946554496},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1457946554477},{"_id":"themes/next/layout/_partials/comments.swig","hash":"325dd5923d845a539fc0524ca72ce40edd1e516a","modified":1457946554476},{"_id":"themes/next/layout/_partials/footer.swig","hash":"cba20577cea89196d714ddfe6b3ea00f7c906ba7","modified":1457946554477},{"_id":"themes/next/layout/_partials/head.swig","hash":"0e37bcbd15d08865c3e84fae9b072ed3f641ae08","modified":1458024359447},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1457946554478},{"_id":"themes/next/layout/_partials/search.swig","hash":"95b55fe35f2d2c22f2cc055d4379b5435314c7ec","modified":1457946554479},{"_id":"themes/next/layout/_partials/header.swig","hash":"b9c0b6961affd8e2140002a5f84abd264c80805c","modified":1458022845477},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1457946554482},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1457946554483},{"_id":"source/_posts/20160418-02/handler.jpg","hash":"2c7429b86f22a746098bc1003a47df07791e86a3","modified":1460952475268},{"_id":"themes/next/layout/_macro/post.swig","hash":"4fc548ae72054b9950f17f3dfa90a6ac81406bde","modified":1458024385152},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6de4ea6db39fe8e04b058bcefc5b23f954726e77","modified":1457946554476},{"_id":"themes/next/layout/_macro/reward.swig","hash":"89f3d2e978d4062b470e774eda21c2ed3a086ab9","modified":1457946554475},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"b87a5122dbff1d5fccf8f3d09d1640bd4b01c4a0","modified":1457946554474},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"1a51b8caa5130ff55948ae59dddb87ee0550c1e9","modified":1457946554491},{"_id":"source/_posts/20160415-01/class_life.jpg","hash":"42402afef2baad95713cc2e5bd7d2862f2713e73","modified":1460730798518},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1457946554531},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1457946554532},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1457946554533},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1457946554532},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1457946554533},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1457946554534},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1457946554535},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1457946554535},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1457946554534},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1457946554534},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1457946554535},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1457946554536},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1457946554536},{"_id":"source/_posts/20160328-01/java-thread.jpg","hash":"2e341a7fe230b9026a42084693a8103054b645bc","modified":1459171642071},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1457946540740},{"_id":"source/_posts/20160423-01/io.png","hash":"f171c4a7fdcd7215fb4e5b30247756690e83084d","modified":1461398939543},{"_id":"themes/next/.git/logs/HEAD","hash":"c834975909d2c75037ba385ebf348cb4d28b393e","modified":1457946554427},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1457946540736},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1457946540737},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1457946540737},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1457946540739},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1457946540738},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1457946540738},{"_id":"source/_posts/20160417-01/command.jpg","hash":"37e63f27af5850eeb1df90a58b65c76367599310","modified":1460881225961},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1457946540738},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1457946554484},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1457946554484},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1457946540737},{"_id":"source/_posts/20151226-01/Image01.png","hash":"d143ebd7095122f78ffdfe08d179cb9e780efa65","modified":1458055823373},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1457946554520},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1457946554520},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1457946554521},{"_id":"themes/next/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1457946540739},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1457946554529},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1457946554530},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1457946554480},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1457946554479},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"241505c3c778f6b5dcc8db48f8f86ec87ade8a0f","modified":1457946554479},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"6fa4daa91adee5800cbb0954e571b75e9796f99b","modified":1457946554483},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"91c5353fcb94cc3b3f265b06ad2341734bc4c826","modified":1457946554485},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"8ba01f1ac07fbca62a4b00f5a0a3a506122c1530","modified":1457946554488},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"66d6e04f17103a263d74b2ad73d392d81531f159","modified":1457946554490},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1457946554490},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1457946554484},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"4a0da1bed19e65bd7db42421b447061bc1618710","modified":1457946554538},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1457946554537},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1457946554538},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1457946554540},{"_id":"themes/next/source/js/src/motion.js","hash":"ff9ea37d05c269e3a140c4ab448af03efc4bcc76","modified":1457946554539},{"_id":"themes/next/source/js/src/utils.js","hash":"efcb2a7de9dc371d03a8598da2d71e2c53132d4c","modified":1457946554541},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"bf8e9223a40748b2e3ef77d753a8e1dbbce8095e","modified":1457946554480},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"12684840de632eb16e53ffa863166306a756fd4f","modified":1457946554482},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"3fdde03f45a80f7a85097a40b40358adde618fc7","modified":1457946554481},{"_id":"themes/next/source/vendors/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1457946554541},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1457946554579},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1457946554481},{"_id":"themes/next/source/vendors/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1457946554541},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"aebc73513c9cbbbbda2935e2eb18e09bb1c24bf8","modified":1457946554489},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"8eecd19c756df615afb3f5ec6a527cd7bd06d20c","modified":1457946554490},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1457946554580},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1457946554581},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1457946554582},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1457946554519},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1457946554581},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1457946554583},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1457946554586},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1457946554582},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1457946554586},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1457946554589},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1457946554589},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1457946554590},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1457946554520},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"10ca6744a8594c1a085b50120f4ed0a1ef433f40","modified":1457946554521},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e55265c8a8a6ae0c3c08e3509de92ee62c3cb5f6","modified":1457946554529},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1457946554549},{"_id":"themes/next/source/css/_variables/default.styl","hash":"17779fa6fa3c9e1262ba100a86a8dec730c2f312","modified":1457946554531},{"_id":"themes/next/source/css/_variables/base.styl","hash":"f171c71d42f8798608235206dd41b37193faed88","modified":1457946554530},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"9f87ded9cde425048e8ae063cbb481e78a0e469c","modified":1457946554530},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1457946554550},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1457946554551},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"ed80b43dbc7e3009b2f436741b9796df8eb3be02","modified":1457946554555},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1457946554555},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1457946554555},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1457946554554},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"bb093f2ac1f1305069d873a7941324c8e0de3135","modified":1457946554554},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1457946554550},{"_id":"themes/next/.git/refs/heads/master","hash":"42617d7e6b9d84ec20ba3585469380e3d4113f47","modified":1457946554425},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1457946554580},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"c1186e609d4810ebfb3e675e9045b023a557d1db","modified":1457946554488},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"da8aa3beab56d8c306dd97cf41127a3859e2d00c","modified":1457946554489},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8b37699252a24741716b40fb70972a77453cbfe1","modified":1457946554540},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1457946554542},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1457946554542},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1457946554543},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1457946554543},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1457946554544},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1457946554543},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1457946554547},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1457946554549},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1457946554548},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1457946554585},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1457946554585},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5a35aa0381b0e1d465b952a997194441020446ea","modified":1457946554518},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"c9218b48c56e52c06af9ce3cc8fbdae737cf16fe","modified":1457946554519},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9da0ffa38fb3916ebadbaf99cb9ffd3057f730ac","modified":1457946554518},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1457946554518},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"d110befc142dbb881c4fdcb94df65ed2f603f1c1","modified":1457946554519},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1457946554517},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"096e7a6958b3bcacaa94361266832871ccb989c0","modified":1457946554486},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"61347b9cf5c42a02f28cda4b6d920d6d17099d44","modified":1457946554486},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1457946554487},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"1b6af02fd0ba3f729675cd95429a0cea4aebf358","modified":1457946554487},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"ae5b8597603d4e42ee66ed121544e7b1c644767e","modified":1457946554486},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1457946554523},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1457946554522},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1457946554522},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"55b44e03054cd20ed8129bf986b15fba5fd85aad","modified":1457946554523},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5187512cc4b2ce095230928c7046e0b26c3897bd","modified":1457946554524},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1457946554522},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1457946554523},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1457946554552},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1457946554553},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"b7d5cc29586ac796a50d90974ad99d24a5982137","modified":1457946554499},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ad69cbf94eedacc27e756cdb9c7073416db697d0","modified":1457946554497},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"88559b13ce94311405b170a0506ded91273beceb","modified":1457946554506},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1457946554513},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"59c0f66602ebc1c05c16f117bc8710d9f3744538","modified":1457946554526},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1457946554528},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"f575b82c8562a5cf1d0fb586c56a739ae70a35d3","modified":1457946554528},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"de31e923bf5102498f06b1ae6bdf2ea22409f3e0","modified":1457946554526},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"88a5e0e95f93e4adb196bff1aac17d6cfb03768a","modified":1457946554529},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"124b540f059fd1ed13514362007cfc70355278c6","modified":1457946554525},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"96f95471da25d0e80c6b82f1e834b03c9aba58a9","modified":1457946554527},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1457946554525},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"8ffc548c9b61babf2781a35273797f45d3e4a2bd","modified":1457946554525},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"f70fa81275eb4e0ea5e5a740b7a35539c6ffa9ba","modified":1457946554526},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1457946554525},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"802e599b1ac749eac162dae396f66b0acaa5edcc","modified":1457946554528},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"c834975909d2c75037ba385ebf348cb4d28b393e","modified":1457946554426},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1457946554499},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1457946554420},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"22828f5141c0cecb9ef25a110e194cdfa3a36423","modified":1457946554498},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"811432ad1e2d6c1f6da9a63fd919bf2a02b71dd9","modified":1457946554556},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1457946554557},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"4c2c5f5f6cc86d775a44b944661e038b7be98149","modified":1457946554570},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1457946554578},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1457946554588},{"_id":"themes/next/.git/objects/pack/pack-0803ab0e1b28c11eec08ba4eca6c3656dbc6413b.idx","hash":"8ff5c43cdad2470b975cbfa76884aa6a4a693d02","modified":1457946554146},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1457946554572},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1457946554571},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1457946554577},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1457946554545},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1457946554544},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1457946554546},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1457946554546},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1457946554547},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1457946554546},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1457946554524},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4c4ef6e997d0c6e21de39c2daa0c768e12c8c6fa","modified":1457946554500},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"627cdd38b34b15c9fc17f4dc332b1be928f8ed0d","modified":1457946554503},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"9f0606d4d94ffa6bd77f91628507bba19133cf36","modified":1457946554503},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1457946554501},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1457946554501},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"a5c4434940cb3ed9d16f361acf7c0cdbf7587f6c","modified":1457946554502},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1457946554502},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1457946554505},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1457946554515},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"f168f79ba8cc80c775907da4cc00d01771ac1e1e","modified":1457946554502},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"b8f9c95702e87fd0b170ab586c82c9718a245f8a","modified":1457946554505},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"6c34f2cf9ad9b9b787007cfca522deeb6b1ae3b7","modified":1457946554504},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1457946554516},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"8539c1122966a6aea64267d48af05603caa5fa29","modified":1457946554504},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"0f368e6e95c0ba46580b491819e46ae31910c94b","modified":1457946554517},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1457946554516},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"a83f493e494f5c73fab8f6f5b686ef1670490095","modified":1457946554515},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"45ebfa59454dffe74ba9d86eb743dc84e4e449d2","modified":1457946554516},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"dd941824210733588841897457e0cc9697ca5608","modified":1457946554514},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1457946554508},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1457946554507},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1457946554515},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1457946554514},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"c9e3c5aca361ed9bbfa41a9755f3c516025da67e","modified":1457946554508},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"4866fb9453d7d4c83a1c4e55d74e4afed336eb8b","modified":1457946554507},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"929fac3a505bacbce6ba63009fd15851e2a8669d","modified":1457946554509},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"68ed6b0ad40745cb07ecd38f13960bb217aef848","modified":1457946554506},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1457946554509},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"5dba4ca272d7c767b57233cd99fba95dbf82153f","modified":1457946554508},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1457946554510},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"758d64ad65f718537ab5bfe5592a626abc40987e","modified":1457946554509},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"98ab1039ec0726ba217a2f318ca53b737d07857c","modified":1457946554510},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"c834975909d2c75037ba385ebf348cb4d28b393e","modified":1457946554424},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"70407054dbb5180c69e50ea2655d32835494394e","modified":1457946554511},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"7f2bdd6109614d35408ee5ac3335aad4464c69c7","modified":1457946554510},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1457946554511},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"99c4b7d1459569cda394c733845d368008a180bf","modified":1457946554513},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"97832be1f30b631dbc2202524918b6eb55e74c4b","modified":1457946554512},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"821991c0890966a512b43e8b1cf9537e738a09a0","modified":1457946554511},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"06b9a99d63b4d57fdbf70b88ab7036fbc47e3f52","modified":1457946554513},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1457946554512},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"546ad04994f74643334fd36cdb548c17f71b11be","modified":1457946554513},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1457946554577},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"f346b8b3df147e4059e1a7d66c52c9a6e1cec3e8","modified":1457946554575},{"_id":"themes/next/.git/objects/pack/pack-0803ab0e1b28c11eec08ba4eca6c3656dbc6413b.pack","hash":"c6d6d8d1af784752f56e9eaa2db97816dd578f12","modified":1457946554196},{"_id":"public/about/index.html","hash":"4496f69e5fe35dc08bc2b4d9adff7a51c610f72e","modified":1461425208402},{"_id":"public/categories/index.html","hash":"d971219b43ed9fa8bea6f55292227129ad62e4ab","modified":1461425208404},{"_id":"public/tags/index.html","hash":"2857d0cddd45fa56f26f34807103a476fec851e9","modified":1461425208404},{"_id":"public/categories/软件使用/index.html","hash":"0f83f04842f1c4f0b5ba7ed5c2de083ad36b57f5","modified":1461425208404},{"_id":"public/categories/Android/index.html","hash":"b105e12bdef194da3e6c745cb8bccd2c482bb762","modified":1461425208404},{"_id":"public/categories/设计模式/index.html","hash":"3139e14298846474290d1cd87c33ad76a2eed396","modified":1461425208405},{"_id":"public/tags/Android/index.html","hash":"dff58d97aa38a208c931cab3afc4306a1ebb3181","modified":1461425208405},{"_id":"public/tags/software/index.html","hash":"2aff7a974c2059de7f2b5e5240301499aa5826ec","modified":1461425208405},{"_id":"public/tags/java/page/2/index.html","hash":"3572afd880280512fb9748b7effa8ad98e41bcc5","modified":1461425208405},{"_id":"public/tags/软件使用/index.html","hash":"1392c2fa9e7dcff2d25a530ac83a02df1eb61e14","modified":1461425208405},{"_id":"public/tags/java虚拟机/index.html","hash":"8ad39b2695c9c13cfa25cf7dac3bf730d018af80","modified":1461425208405},{"_id":"public/2016/04/18/20160418-02/index.html","hash":"942e9e96d78a382d9c518305d2611e30c5f237fc","modified":1461645866508},{"_id":"public/2016/04/18/20160418-01/index.html","hash":"184ea53c5ceedae1e43751e1de4b52b359593fa6","modified":1461425208405},{"_id":"public/2016/04/17/20160417-01/index.html","hash":"249b5868c08f458bc4645d90435efacdfa2eeeaa","modified":1461425208405},{"_id":"public/2016/04/16/20160416-01/index.html","hash":"61d914bf1b1716983b73f00c4a8213ec8e942771","modified":1461425208405},{"_id":"public/2016/04/15/20160415-01/index.html","hash":"7624577fe8c06e593e96afd20c26d8419768fe13","modified":1461425208405},{"_id":"public/2016/04/09/20160409-01/index.html","hash":"c085a080d0702b423173752320db3d9d36412cd4","modified":1461425208405},{"_id":"public/2016/04/08/20160408-01/index.html","hash":"b3f723e063b906720fba5d96c5d911310714952f","modified":1461425208406},{"_id":"public/2016/03/28/20160328-01/index.html","hash":"70ae442f5316f538df81e12dbf8c93d77929253b","modified":1461425208409},{"_id":"public/2016/03/24/20160324-03/index.html","hash":"326b271ff8a95027f61ba0ee48cb5a0992a80b47","modified":1461425208409},{"_id":"public/2016/03/24/20160324-02/index.html","hash":"5efcf74ea5283d404efffd503fd42966f9f82eac","modified":1461425208409},{"_id":"public/2016/03/24/20160324-01/index.html","hash":"edd86766e4144633e6f2ddfff6922d48451b7784","modified":1461425208409},{"_id":"public/2016/03/23/20160323-01/index.html","hash":"aa1e8ae9e4c03a09ca9334d31a984cee443626ff","modified":1461425208409},{"_id":"public/2016/03/20/project_learning/index.html","hash":"1bace179060b299a3e94c904cda47d2824ed407d","modified":1461425208409},{"_id":"public/2016/02/07/20160207-01/index.html","hash":"dded60ec8e9023939321a3ef8a0da68fdd527bbf","modified":1461425208409},{"_id":"public/2016/02/05/20160205-01/index.html","hash":"20b0394aac86f130eeb59e411920749c532d94dc","modified":1461425208409},{"_id":"public/2016/01/29/20160129-01/index.html","hash":"930da73e9858e410e30975ad80e693151bbdf94d","modified":1461425208409},{"_id":"public/2016/01/25/20160125-01/index.html","hash":"1a222daf4a69c748491f1c1c001b81f6078cd5bf","modified":1461425208409},{"_id":"public/2015/12/26/20151226-01/index.html","hash":"5b585961d3789ac6f96a9f738f82090605f82214","modified":1461425208409},{"_id":"public/categories/java/index.html","hash":"700fb5cf7af655e3339693da168831d86e6f8594","modified":1461425208409},{"_id":"public/tags/java/index.html","hash":"413a64244ccbbae8599b00496959d8e0391cf1d7","modified":1461425208409},{"_id":"public/categories/计算机原理/index.html","hash":"939654b5bfd67a3bc0e7091b73a685a55e6f30d4","modified":1461645866507},{"_id":"public/tags/设计模式/index.html","hash":"d835cabc034a3e77519691742ce80cae6bd5eece","modified":1461425208455},{"_id":"public/archives/2015/index.html","hash":"a208c812feed9fbf2295a2a155d510f685a4d25e","modified":1461425208455},{"_id":"public/archives/2015/12/index.html","hash":"9b1233c36555cdbb405a29b1c907e9261317405a","modified":1461425208455},{"_id":"public/archives/2016/page/2/index.html","hash":"62a0a55fb28ad47f777a37c4bd052da27a2373b8","modified":1461425208455},{"_id":"public/archives/2016/01/index.html","hash":"01e494481ee048828b8c00acb9d04f4ca44178d5","modified":1461425208455},{"_id":"public/archives/2016/02/index.html","hash":"aa5d53e3b45035c39ea6f851fc8004154c3e637f","modified":1461425208455},{"_id":"public/archives/2016/03/index.html","hash":"df909213262915c8d6e90025ff30ecc8eb10b076","modified":1461425208455},{"_id":"public/archives/2016/04/index.html","hash":"1650290df8bbc7c51e45b266618fc1dbd9d6721f","modified":1461645866507},{"_id":"public/2016/04/23/20160423-01/index.html","hash":"faaed5dc49915bf483a00accd65dc1295d450c38","modified":1461930301434},{"_id":"public/index.html","hash":"e7f8620fc514b6071b86c0d8c7706028001bb1da","modified":1461645866509},{"_id":"public/page/2/index.html","hash":"7c351364f2592bfc9506206b872907e388fbd663","modified":1461425208456},{"_id":"public/archives/index.html","hash":"13cdf897838bce01618ba0af2d56acdc6bda111d","modified":1461645866508},{"_id":"public/archives/page/2/index.html","hash":"4c4950475a78bf7302e5f9a9743be888f8f19100","modified":1461425208456},{"_id":"public/archives/2016/index.html","hash":"e9fa91ed89b9228ca688cdfc71535bd23fe0fc7f","modified":1461645866509},{"_id":"public/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1461425208456},{"_id":"public/tags/操作系统/index.html","hash":"efbd0c55afefed91b8948acdba524300c8a97997","modified":1461645866508},{"_id":"public/favicon.ico","hash":"96755b44d24cf7dd57d460b8b72d2d5685737160","modified":1461425208465},{"_id":"public/CNAME","hash":"43929ad14a150f8d53c881bf1dbf7784a1880bae","modified":1461425208465},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1461425208465},{"_id":"public/images/profile.jpg","hash":"541dfe115b7ed973d0d39bfbe63ad2d3dd914033","modified":1461425208465},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1461425208465},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1461425208466},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1461425208466},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1461425208466},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1461425208466},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1461425208466},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1461425208466},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1461425208466},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1461425208466},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1461425208466},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1461425208466},{"_id":"public/vendors/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1461425208466},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","hash":"ed80b43dbc7e3009b2f436741b9796df8eb3be02","modified":1461425208466},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1461425208466},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1461425208466},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1461425208466},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1461425208466},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1461425208466},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1461425208467},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1461425208467},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1461425208467},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1461425208467},{"_id":"public/2016/03/23/20160323-01/example.jpg","hash":"9e72a1f8b6d0577ebe0fb190adfc46d3d29d4076","modified":1461425208468},{"_id":"public/2016/04/08/20160408-01/memory.jpg","hash":"7d19c0a904c4d127e1a0b7a23ccf85db17ede9bc","modified":1461425208468},{"_id":"public/2016/04/18/20160418-02/handler.jpg","hash":"2c7429b86f22a746098bc1003a47df07791e86a3","modified":1461425208468},{"_id":"public/2016/04/15/20160415-01/class_life.jpg","hash":"42402afef2baad95713cc2e5bd7d2862f2713e73","modified":1461425208468},{"_id":"public/2016/04/15/20160415-01/classloader.jpg","hash":"cc00f5a79e04b7f017c329b1165e67d3cccd54c0","modified":1461425208468},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1461425209405},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1461425209414},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1461425209414},{"_id":"public/2016/04/17/20160417-01/command.jpg","hash":"37e63f27af5850eeb1df90a58b65c76367599310","modified":1461425209415},{"_id":"public/2016/03/28/20160328-01/java-thread.jpg","hash":"2e341a7fe230b9026a42084693a8103054b645bc","modified":1461425209415},{"_id":"public/2016/04/23/20160423-01/io.png","hash":"f171c4a7fdcd7215fb4e5b30247756690e83084d","modified":1461425209415},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1461425209432},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1461425209432},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1461425209432},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1461425209432},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1461425209432},{"_id":"public/js/src/utils.js","hash":"cf24307d8aeb18e9bad093647c7fb50dc3d9fbe8","modified":1461425209432},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1461425209432},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1461425209432},{"_id":"public/vendors/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1461425209432},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1461425209432},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1461425209432},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1461425209432},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1461425209432},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1461425209432},{"_id":"public/vendors/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1461425209432},{"_id":"public/js/src/schemes/pisces.js","hash":"94f935331995bfeadf1084fb8f0665ab39fd1c8d","modified":1461425209432},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1461425209432},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1461425209432},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1461425209432},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1461425209432},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1461425209432},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1461425209432},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1461425209432},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1461425209432},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1461425209433},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1461425209433},{"_id":"public/css/main.css","hash":"e2c262c645a0a4f5c21db215c33b41e784b5dbae","modified":1461425209433},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1461425209433},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1461425209433},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1461425209433},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1461425209434},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1461425209434},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1461425209434},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1461425209434},{"_id":"public/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1461425209434},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1461425209434},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1461425209434},{"_id":"public/2015/12/26/20151226-01/Image01.png","hash":"d143ebd7095122f78ffdfe08d179cb9e780efa65","modified":1461425209434},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"f346b8b3df147e4059e1a7d66c52c9a6e1cec3e8","modified":1461425209454},{"_id":"source/_posts/20160423-01/buffer.jpg","hash":"b6d6750c7396401e5f47e30d8b76481a86bff8a6","modified":1461645836307},{"_id":"public/2016/04/23/20160423-01/buffer.jpg","hash":"b6d6750c7396401e5f47e30d8b76481a86bff8a6","modified":1461645866518}],"Category":[{"name":"软件使用","_id":"cindau1w0000530xgw7zi0u1q"},{"name":"java","_id":"cindau1wn000g30xg6jfd9e41"},{"name":"Android","_id":"cindau1x1000v30xgospaifyz"},{"name":"设计模式","_id":"cindau1xe001c30xgx4y9dxny"},{"name":"计算机原理","_id":"cindau1xm001l30xgvtc626bs"}],"Data":[],"Page":[{"title":"about","date":"2016-03-15T02:29:29.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-03-15 10:29:29\n---\n","updated":"2016-03-15T02:29:29.668Z","path":"about/index.html","comments":1,"layout":"page","_id":"cindau1vr000130xghaqtlm51","content":"","excerpt":"","more":""},{"title":"categories","date":"2016-03-15T05:27:44.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-03-15 13:27:44\ntype: \"categories\"\n\n---\n","updated":"2016-03-15T05:28:21.243Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cindau1vw000330xg36vb0ca0","content":"","excerpt":"","more":""},{"title":"tags","date":"2016-03-15T02:36:07.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-03-15 10:36:07\ntype: \"tags\"\n---\n","updated":"2016-03-15T02:36:36.317Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cindau1w2000730xgyaw0segb","content":"","excerpt":"","more":""}],"Post":[{"title":"genymotion windows兼容性问题","date":"2015-12-26T15:28:52.000Z","_content":"\n\n{% asset_img Image01.png This is an example image %}\n\n\n貌似在这个<font color=red>ghost</font>系统下，经过我的测试只有4.3.1.2可以完美运行virtualbox ","source":"_posts/20151226-01.md","raw":"---\ntitle: genymotion windows兼容性问题\ndate: 2015-12-26 23:28:52\ntags: \n - Android \n - software\ncategories: 软件使用\n\n---\n\n\n{% asset_img Image01.png This is an example image %}\n\n\n貌似在这个<font color=red>ghost</font>系统下，经过我的测试只有4.3.1.2可以完美运行virtualbox ","slug":"20151226-01","published":1,"updated":"2016-03-16T10:45:04.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cindau1vk000030xgpdcrpzmi","content":"<img src=\"/2015/12/26/20151226-01/Image01.png\" alt=\"This is an example image\" title=\"This is an example image\">\n<p>貌似在这个<font color=\"red\">ghost</font>系统下，经过我的测试只有4.3.1.2可以完美运行virtualbox </p>\n","excerpt":"","more":"<img src=\"/2015/12/26/20151226-01/Image01.png\" alt=\"This is an example image\" title=\"This is an example image\">\n<p>貌似在这个<font color=red>ghost</font>系统下，经过我的测试只有4.3.1.2可以完美运行virtualbox </p>\n"},{"title":"个人idea快捷键整理","date":"2016-01-25T10:37:19.000Z","_content":"\n# IntelliJ Idea常用快捷键\n\n整理一下常用快捷键\n\nAlt+回车 导入包,自动修正\nCtrl+N   查找类  \nCtrl+Shift+N 查找文件  \nCtrl+Alt+L  格式化代码  \nCtrl+Alt+O 优化导入的类和包  \nAlt+Insert 生成代码(如get,set方法,构造函数等)  \nCtrl+E或者Alt+Shift+C  最近更改的代码  \nCtrl+R 替换文本  \nCtrl+F 查找文本  \nCtrl+Shift+Space 自动补全代码  \nCtrl+空格 代码提示  \nCtrl+Alt+Space 类名或接口名提示  \nCtrl+P 方法参数提示  \nCtrl+Shift+Alt+N 查找类中的方法或变量  \nAlt+Shift+C 对比最近修改的代码  \n \nShift+F6  重构-重命名  \nCtrl+Shift+先上键  \nCtrl+X 删除行  \nCtrl+D 复制行  \nCtrl+/ 或 Ctrl+Shift+/  注释（// 或者/*...*/ ）  \nCtrl+J  自动代码  \nCtrl+E 最近打开的文件  \nCtrl+H 显示类结构图  \nCtrl+Q 显示注释文档  \nAlt+F1 查找代码所在位置  \nAlt+1 快速打开或隐藏工程面板  \nCtrl+Alt+ left/right 返回至上次浏览的位置  \nAlt+ left/right 切换代码视图  \nAlt+ Up/Down 在方法间快速移动定位  \nCtrl+Shift+Up/Down 代码向上/下移动。  \nF2 或Shift+F2 高亮错误或警告快速定位  \n \n代码标签输入完成后，按Tab，生成代码。  \n选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。  \nCtrl+W 选中代码，连续按会有其他效果  \n选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。  \nCtrl+Up/Down 光标跳转到第一行或最后一行下  \nCtrl+B 快速打开光标处的类或方法   ","source":"_posts/20160125-01.md","raw":"---\ntitle: 个人idea快捷键整理\ndate: 2016-01-25 18:37:19\ntags: \n - java \n - Android \n - software\ncategories: 软件使用 \n---\n\n# IntelliJ Idea常用快捷键\n\n整理一下常用快捷键\n\nAlt+回车 导入包,自动修正\nCtrl+N   查找类  \nCtrl+Shift+N 查找文件  \nCtrl+Alt+L  格式化代码  \nCtrl+Alt+O 优化导入的类和包  \nAlt+Insert 生成代码(如get,set方法,构造函数等)  \nCtrl+E或者Alt+Shift+C  最近更改的代码  \nCtrl+R 替换文本  \nCtrl+F 查找文本  \nCtrl+Shift+Space 自动补全代码  \nCtrl+空格 代码提示  \nCtrl+Alt+Space 类名或接口名提示  \nCtrl+P 方法参数提示  \nCtrl+Shift+Alt+N 查找类中的方法或变量  \nAlt+Shift+C 对比最近修改的代码  \n \nShift+F6  重构-重命名  \nCtrl+Shift+先上键  \nCtrl+X 删除行  \nCtrl+D 复制行  \nCtrl+/ 或 Ctrl+Shift+/  注释（// 或者/*...*/ ）  \nCtrl+J  自动代码  \nCtrl+E 最近打开的文件  \nCtrl+H 显示类结构图  \nCtrl+Q 显示注释文档  \nAlt+F1 查找代码所在位置  \nAlt+1 快速打开或隐藏工程面板  \nCtrl+Alt+ left/right 返回至上次浏览的位置  \nAlt+ left/right 切换代码视图  \nAlt+ Up/Down 在方法间快速移动定位  \nCtrl+Shift+Up/Down 代码向上/下移动。  \nF2 或Shift+F2 高亮错误或警告快速定位  \n \n代码标签输入完成后，按Tab，生成代码。  \n选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。  \nCtrl+W 选中代码，连续按会有其他效果  \n选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。  \nCtrl+Up/Down 光标跳转到第一行或最后一行下  \nCtrl+B 快速打开光标处的类或方法   ","slug":"20160125-01","published":1,"updated":"2016-03-16T10:45:14.647Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cindau1vu000230xge894hsbc","content":"<h1 id=\"IntelliJ-Idea常用快捷键\"><a href=\"#IntelliJ-Idea常用快捷键\" class=\"headerlink\" title=\"IntelliJ Idea常用快捷键\"></a>IntelliJ Idea常用快捷键</h1><p>整理一下常用快捷键</p>\n<p>Alt+回车 导入包,自动修正<br>Ctrl+N   查找类<br>Ctrl+Shift+N 查找文件<br>Ctrl+Alt+L  格式化代码<br>Ctrl+Alt+O 优化导入的类和包<br>Alt+Insert 生成代码(如get,set方法,构造函数等)<br>Ctrl+E或者Alt+Shift+C  最近更改的代码<br>Ctrl+R 替换文本<br>Ctrl+F 查找文本<br>Ctrl+Shift+Space 自动补全代码<br>Ctrl+空格 代码提示<br>Ctrl+Alt+Space 类名或接口名提示<br>Ctrl+P 方法参数提示<br>Ctrl+Shift+Alt+N 查找类中的方法或变量<br>Alt+Shift+C 对比最近修改的代码  </p>\n<p>Shift+F6  重构-重命名<br>Ctrl+Shift+先上键<br>Ctrl+X 删除行<br>Ctrl+D 复制行<br>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>…</em>/ ）<br>Ctrl+J  自动代码<br>Ctrl+E 最近打开的文件<br>Ctrl+H 显示类结构图<br>Ctrl+Q 显示注释文档<br>Alt+F1 查找代码所在位置<br>Alt+1 快速打开或隐藏工程面板<br>Ctrl+Alt+ left/right 返回至上次浏览的位置<br>Alt+ left/right 切换代码视图<br>Alt+ Up/Down 在方法间快速移动定位<br>Ctrl+Shift+Up/Down 代码向上/下移动。<br>F2 或Shift+F2 高亮错误或警告快速定位  </p>\n<p>代码标签输入完成后，按Tab，生成代码。<br>选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。<br>Ctrl+W 选中代码，连续按会有其他效果<br>选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。<br>Ctrl+Up/Down 光标跳转到第一行或最后一行下<br>Ctrl+B 快速打开光标处的类或方法   </p>\n","excerpt":"","more":"<h1 id=\"IntelliJ-Idea常用快捷键\"><a href=\"#IntelliJ-Idea常用快捷键\" class=\"headerlink\" title=\"IntelliJ Idea常用快捷键\"></a>IntelliJ Idea常用快捷键</h1><p>整理一下常用快捷键</p>\n<p>Alt+回车 导入包,自动修正<br>Ctrl+N   查找类<br>Ctrl+Shift+N 查找文件<br>Ctrl+Alt+L  格式化代码<br>Ctrl+Alt+O 优化导入的类和包<br>Alt+Insert 生成代码(如get,set方法,构造函数等)<br>Ctrl+E或者Alt+Shift+C  最近更改的代码<br>Ctrl+R 替换文本<br>Ctrl+F 查找文本<br>Ctrl+Shift+Space 自动补全代码<br>Ctrl+空格 代码提示<br>Ctrl+Alt+Space 类名或接口名提示<br>Ctrl+P 方法参数提示<br>Ctrl+Shift+Alt+N 查找类中的方法或变量<br>Alt+Shift+C 对比最近修改的代码  </p>\n<p>Shift+F6  重构-重命名<br>Ctrl+Shift+先上键<br>Ctrl+X 删除行<br>Ctrl+D 复制行<br>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>…</em>/ ）<br>Ctrl+J  自动代码<br>Ctrl+E 最近打开的文件<br>Ctrl+H 显示类结构图<br>Ctrl+Q 显示注释文档<br>Alt+F1 查找代码所在位置<br>Alt+1 快速打开或隐藏工程面板<br>Ctrl+Alt+ left/right 返回至上次浏览的位置<br>Alt+ left/right 切换代码视图<br>Alt+ Up/Down 在方法间快速移动定位<br>Ctrl+Shift+Up/Down 代码向上/下移动。<br>F2 或Shift+F2 高亮错误或警告快速定位  </p>\n<p>代码标签输入完成后，按Tab，生成代码。<br>选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。<br>Ctrl+W 选中代码，连续按会有其他效果<br>选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。<br>Ctrl+Up/Down 光标跳转到第一行或最后一行下<br>Ctrl+B 快速打开光标处的类或方法   </p>\n"},{"title":"java中的堆内存和栈内存","date":"2016-01-29T12:29:06.000Z","_content":"\njava中内存也是大致有**栈内存**和**堆内存**  \n当代码中定义一些基本类型变量或者引用变量，虚拟机会在**栈**中分配内存  \n然后到这个作用域结束，java会自动回收该部分内存  \n而当你要new对象或者数组，这块内存将会在**堆**里分配。这块内存会有java虚拟机来自动回收。  \n所谓的 **引用变量**，类似于 **指针**，是分配在栈内存当中的，然而指向堆内存。当一个new出来的对象没有再被引用指向的时候，就会被垃圾回收器在不定时清掉。\n\n## 内存分配策略\n\n### 1.静态存储分配\n在编译的时候就能确定每个数据目标的存储空间，不允许可变数据结构。\n### 2.栈式存储分配\n编译时对程序区未知，只有到运行，在进入某一个程序区块时候，才能为其分配内存。栈式内存符合先进后出\n### 3.堆式存储分配\n堆中的内存无法在编译时和运行时确定，可按任意顺序分配释放\n\n\n---\n\n\n","source":"_posts/20160129-01.md","raw":"---\ntitle: java中的堆内存和栈内存\ndate: 2016-01-29 20:29:06\ntags: \n - java\ncategories: java\n\n---\n\njava中内存也是大致有**栈内存**和**堆内存**  \n当代码中定义一些基本类型变量或者引用变量，虚拟机会在**栈**中分配内存  \n然后到这个作用域结束，java会自动回收该部分内存  \n而当你要new对象或者数组，这块内存将会在**堆**里分配。这块内存会有java虚拟机来自动回收。  \n所谓的 **引用变量**，类似于 **指针**，是分配在栈内存当中的，然而指向堆内存。当一个new出来的对象没有再被引用指向的时候，就会被垃圾回收器在不定时清掉。\n\n## 内存分配策略\n\n### 1.静态存储分配\n在编译的时候就能确定每个数据目标的存储空间，不允许可变数据结构。\n### 2.栈式存储分配\n编译时对程序区未知，只有到运行，在进入某一个程序区块时候，才能为其分配内存。栈式内存符合先进后出\n### 3.堆式存储分配\n堆中的内存无法在编译时和运行时确定，可按任意顺序分配释放\n\n\n---\n\n\n","slug":"20160129-01","published":1,"updated":"2016-03-16T13:10:53.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cindau1w0000630xg5b15mk3m","content":"<p>java中内存也是大致有<strong>栈内存</strong>和<strong>堆内存</strong><br>当代码中定义一些基本类型变量或者引用变量，虚拟机会在<strong>栈</strong>中分配内存<br>然后到这个作用域结束，java会自动回收该部分内存<br>而当你要new对象或者数组，这块内存将会在<strong>堆</strong>里分配。这块内存会有java虚拟机来自动回收。<br>所谓的 <strong>引用变量</strong>，类似于 <strong>指针</strong>，是分配在栈内存当中的，然而指向堆内存。当一个new出来的对象没有再被引用指向的时候，就会被垃圾回收器在不定时清掉。</p>\n<h2 id=\"内存分配策略\"><a href=\"#内存分配策略\" class=\"headerlink\" title=\"内存分配策略\"></a>内存分配策略</h2><h3 id=\"1-静态存储分配\"><a href=\"#1-静态存储分配\" class=\"headerlink\" title=\"1.静态存储分配\"></a>1.静态存储分配</h3><p>在编译的时候就能确定每个数据目标的存储空间，不允许可变数据结构。</p>\n<h3 id=\"2-栈式存储分配\"><a href=\"#2-栈式存储分配\" class=\"headerlink\" title=\"2.栈式存储分配\"></a>2.栈式存储分配</h3><p>编译时对程序区未知，只有到运行，在进入某一个程序区块时候，才能为其分配内存。栈式内存符合先进后出</p>\n<h3 id=\"3-堆式存储分配\"><a href=\"#3-堆式存储分配\" class=\"headerlink\" title=\"3.堆式存储分配\"></a>3.堆式存储分配</h3><p>堆中的内存无法在编译时和运行时确定，可按任意顺序分配释放</p>\n<hr>\n","excerpt":"","more":"<p>java中内存也是大致有<strong>栈内存</strong>和<strong>堆内存</strong><br>当代码中定义一些基本类型变量或者引用变量，虚拟机会在<strong>栈</strong>中分配内存<br>然后到这个作用域结束，java会自动回收该部分内存<br>而当你要new对象或者数组，这块内存将会在<strong>堆</strong>里分配。这块内存会有java虚拟机来自动回收。<br>所谓的 <strong>引用变量</strong>，类似于 <strong>指针</strong>，是分配在栈内存当中的，然而指向堆内存。当一个new出来的对象没有再被引用指向的时候，就会被垃圾回收器在不定时清掉。</p>\n<h2 id=\"内存分配策略\"><a href=\"#内存分配策略\" class=\"headerlink\" title=\"内存分配策略\"></a>内存分配策略</h2><h3 id=\"1-静态存储分配\"><a href=\"#1-静态存储分配\" class=\"headerlink\" title=\"1.静态存储分配\"></a>1.静态存储分配</h3><p>在编译的时候就能确定每个数据目标的存储空间，不允许可变数据结构。</p>\n<h3 id=\"2-栈式存储分配\"><a href=\"#2-栈式存储分配\" class=\"headerlink\" title=\"2.栈式存储分配\"></a>2.栈式存储分配</h3><p>编译时对程序区未知，只有到运行，在进入某一个程序区块时候，才能为其分配内存。栈式内存符合先进后出</p>\n<h3 id=\"3-堆式存储分配\"><a href=\"#3-堆式存储分配\" class=\"headerlink\" title=\"3.堆式存储分配\"></a>3.堆式存储分配</h3><p>堆中的内存无法在编译时和运行时确定，可按任意顺序分配释放</p>\n<hr>\n"},{"title":"java中的注解","date":"2016-02-05T15:12:38.000Z","_content":"\n# java注解的基本定义\n根据维基百科\n> Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据。\nJava语言中的类、方法、变量、参数和包等都可以被标注。Java标注和Javadoc不同，标注有自反性。在编译器生成类文件时，标注可以被嵌入到字节码中，由Java虚拟机执行时获取到标注。\n\n总之注解就是用于一种标记，在程序中加了注解就等于为程序打上了某种标记。程序可以利用java的反射机制来了解你的类及各种元素上有无何种标记，针对不同的标记，就去做相应的事件。标记可以加在包，类，字段，方法，方法的参数以及局部变量上。\n","source":"_posts/20160205-01.md","raw":"---\ntitle: java中的注解\ndate: 2016-02-05 23:12:38\ntags: java\ncategories: java\n---\n\n# java注解的基本定义\n根据维基百科\n> Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据。\nJava语言中的类、方法、变量、参数和包等都可以被标注。Java标注和Javadoc不同，标注有自反性。在编译器生成类文件时，标注可以被嵌入到字节码中，由Java虚拟机执行时获取到标注。\n\n总之注解就是用于一种标记，在程序中加了注解就等于为程序打上了某种标记。程序可以利用java的反射机制来了解你的类及各种元素上有无何种标记，针对不同的标记，就去做相应的事件。标记可以加在包，类，字段，方法，方法的参数以及局部变量上。\n","slug":"20160205-01","published":1,"updated":"2016-03-18T04:34:30.436Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cindau1w3000830xgkziw0t8m","content":"<h1 id=\"java注解的基本定义\"><a href=\"#java注解的基本定义\" class=\"headerlink\" title=\"java注解的基本定义\"></a>java注解的基本定义</h1><p>根据维基百科</p>\n<blockquote>\n<p>Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据。<br>Java语言中的类、方法、变量、参数和包等都可以被标注。Java标注和Javadoc不同，标注有自反性。在编译器生成类文件时，标注可以被嵌入到字节码中，由Java虚拟机执行时获取到标注。</p>\n</blockquote>\n<p>总之注解就是用于一种标记，在程序中加了注解就等于为程序打上了某种标记。程序可以利用java的反射机制来了解你的类及各种元素上有无何种标记，针对不同的标记，就去做相应的事件。标记可以加在包，类，字段，方法，方法的参数以及局部变量上。</p>\n","excerpt":"","more":"<h1 id=\"java注解的基本定义\"><a href=\"#java注解的基本定义\" class=\"headerlink\" title=\"java注解的基本定义\"></a>java注解的基本定义</h1><p>根据维基百科</p>\n<blockquote>\n<p>Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据。<br>Java语言中的类、方法、变量、参数和包等都可以被标注。Java标注和Javadoc不同，标注有自反性。在编译器生成类文件时，标注可以被嵌入到字节码中，由Java虚拟机执行时获取到标注。</p>\n</blockquote>\n<p>总之注解就是用于一种标记，在程序中加了注解就等于为程序打上了某种标记。程序可以利用java的反射机制来了解你的类及各种元素上有无何种标记，针对不同的标记，就去做相应的事件。标记可以加在包，类，字段，方法，方法的参数以及局部变量上。</p>\n"},{"title":"Android中的dp与sp","date":"2016-02-07T09:12:13.000Z","_content":"### dp\n\n我们的手机等设备是有一个实际尺寸的，比如1.5英寸*2英寸这样。这是绝对的单位，然后屏幕有分辨率，显示由像素点构成。这样就有像素密度这个概念了，我们可以得出一个公式\n> 像素密度 = 分辨率 / 实际长度(英寸为单位)\n\n好比 1.5*2 英寸的屏幕是 240\\*320 的，则她的像素密度是\n> 240 / 1.5 = 160 dpi(dots per Inch)\n\n所以不同的手机，里面显示的物体如果根据固定像素现实的话实际长度也可能是不同的，因为像素密度的不同，固定像素 * 像素密度 得到的实际长度当然不一样。而dp就是为了解决这个问题，在像素密度不同的手机设备中，dp会根据不同的系数因子转化。\n> Android系统定义了四种像素密度：低（120dpi）、中（160dpi）、高（240dpi）和超高（320dpi），它们对应的dp到px的系数分别为0.75、1、1.5和2，这个系数乘以dp长度就是像素数。\n\n### sp\n> 与缩放无关的抽象像素（Scale-independent Pixel）。sp和dp很类似但唯一的区别是，Android系统允许用户自定义文字尺寸大小（小、正常、大、超大等等），当文字尺寸是“正常”时1sp=1dp=0.00625英寸，而当文字尺寸是“大”或“超大”时，1sp>1dp=0.00625英寸。类似我们在windows里调整字体尺寸以后的效果——窗口大小不变，只有文字大小改变。\n\n## 总结\n\n反正就是文字尺寸用sp，非文字尺寸用dp。就是如此","source":"_posts/20160207-01.md","raw":"---\n\ntitle: Android中的dp与sp\n\ndate: 2016-02-07 17:12:13\n\ntags: Android\n\ncategories: Android\n\n---\n### dp\n\n我们的手机等设备是有一个实际尺寸的，比如1.5英寸*2英寸这样。这是绝对的单位，然后屏幕有分辨率，显示由像素点构成。这样就有像素密度这个概念了，我们可以得出一个公式\n> 像素密度 = 分辨率 / 实际长度(英寸为单位)\n\n好比 1.5*2 英寸的屏幕是 240\\*320 的，则她的像素密度是\n> 240 / 1.5 = 160 dpi(dots per Inch)\n\n所以不同的手机，里面显示的物体如果根据固定像素现实的话实际长度也可能是不同的，因为像素密度的不同，固定像素 * 像素密度 得到的实际长度当然不一样。而dp就是为了解决这个问题，在像素密度不同的手机设备中，dp会根据不同的系数因子转化。\n> Android系统定义了四种像素密度：低（120dpi）、中（160dpi）、高（240dpi）和超高（320dpi），它们对应的dp到px的系数分别为0.75、1、1.5和2，这个系数乘以dp长度就是像素数。\n\n### sp\n> 与缩放无关的抽象像素（Scale-independent Pixel）。sp和dp很类似但唯一的区别是，Android系统允许用户自定义文字尺寸大小（小、正常、大、超大等等），当文字尺寸是“正常”时1sp=1dp=0.00625英寸，而当文字尺寸是“大”或“超大”时，1sp>1dp=0.00625英寸。类似我们在windows里调整字体尺寸以后的效果——窗口大小不变，只有文字大小改变。\n\n## 总结\n\n反正就是文字尺寸用sp，非文字尺寸用dp。就是如此","slug":"20160207-01","published":1,"updated":"2016-03-19T14:22:53.704Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cindau1wc000a30xgyujm8m8z","content":"<h3 id=\"dp\"><a href=\"#dp\" class=\"headerlink\" title=\"dp\"></a>dp</h3><p>我们的手机等设备是有一个实际尺寸的，比如1.5英寸*2英寸这样。这是绝对的单位，然后屏幕有分辨率，显示由像素点构成。这样就有像素密度这个概念了，我们可以得出一个公式</p>\n<blockquote>\n<p>像素密度 = 分辨率 / 实际长度(英寸为单位)</p>\n</blockquote>\n<p>好比 1.5<em>2 英寸的屏幕是 240\\</em>320 的，则她的像素密度是</p>\n<blockquote>\n<p>240 / 1.5 = 160 dpi(dots per Inch)</p>\n</blockquote>\n<p>所以不同的手机，里面显示的物体如果根据固定像素现实的话实际长度也可能是不同的，因为像素密度的不同，固定像素 * 像素密度 得到的实际长度当然不一样。而dp就是为了解决这个问题，在像素密度不同的手机设备中，dp会根据不同的系数因子转化。</p>\n<blockquote>\n<p>Android系统定义了四种像素密度：低（120dpi）、中（160dpi）、高（240dpi）和超高（320dpi），它们对应的dp到px的系数分别为0.75、1、1.5和2，这个系数乘以dp长度就是像素数。</p>\n</blockquote>\n<h3 id=\"sp\"><a href=\"#sp\" class=\"headerlink\" title=\"sp\"></a>sp</h3><blockquote>\n<p>与缩放无关的抽象像素（Scale-independent Pixel）。sp和dp很类似但唯一的区别是，Android系统允许用户自定义文字尺寸大小（小、正常、大、超大等等），当文字尺寸是“正常”时1sp=1dp=0.00625英寸，而当文字尺寸是“大”或“超大”时，1sp&gt;1dp=0.00625英寸。类似我们在windows里调整字体尺寸以后的效果——窗口大小不变，只有文字大小改变。</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>反正就是文字尺寸用sp，非文字尺寸用dp。就是如此</p>\n","excerpt":"","more":"<h3 id=\"dp\"><a href=\"#dp\" class=\"headerlink\" title=\"dp\"></a>dp</h3><p>我们的手机等设备是有一个实际尺寸的，比如1.5英寸*2英寸这样。这是绝对的单位，然后屏幕有分辨率，显示由像素点构成。这样就有像素密度这个概念了，我们可以得出一个公式</p>\n<blockquote>\n<p>像素密度 = 分辨率 / 实际长度(英寸为单位)</p>\n</blockquote>\n<p>好比 1.5<em>2 英寸的屏幕是 240\\</em>320 的，则她的像素密度是</p>\n<blockquote>\n<p>240 / 1.5 = 160 dpi(dots per Inch)</p>\n</blockquote>\n<p>所以不同的手机，里面显示的物体如果根据固定像素现实的话实际长度也可能是不同的，因为像素密度的不同，固定像素 * 像素密度 得到的实际长度当然不一样。而dp就是为了解决这个问题，在像素密度不同的手机设备中，dp会根据不同的系数因子转化。</p>\n<blockquote>\n<p>Android系统定义了四种像素密度：低（120dpi）、中（160dpi）、高（240dpi）和超高（320dpi），它们对应的dp到px的系数分别为0.75、1、1.5和2，这个系数乘以dp长度就是像素数。</p>\n</blockquote>\n<h3 id=\"sp\"><a href=\"#sp\" class=\"headerlink\" title=\"sp\"></a>sp</h3><blockquote>\n<p>与缩放无关的抽象像素（Scale-independent Pixel）。sp和dp很类似但唯一的区别是，Android系统允许用户自定义文字尺寸大小（小、正常、大、超大等等），当文字尺寸是“正常”时1sp=1dp=0.00625英寸，而当文字尺寸是“大”或“超大”时，1sp&gt;1dp=0.00625英寸。类似我们在windows里调整字体尺寸以后的效果——窗口大小不变，只有文字大小改变。</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>反正就是文字尺寸用sp，非文字尺寸用dp。就是如此</p>\n"},{"title":"Android studio解决gradle下载慢的问题","date":"2016-03-23T12:10:12.000Z","_content":"\ngradle下载被墙是个很恶心的事情，半天构建不出来，所以解决下载慢，要不翻墙，要不只能引用一些国内的景象库来构建。我选择使用shadowsocks走代理的方法，shadowsocks怎么用我不再赘述，假设你已经配置好了shadowsocks并已经在浏览器中可以成功运行了。\n\n那只需在Android studio中，setting 的 http proxy下。如图配置即可\n\n{% asset_img example.jpg This is an example image %}","source":"_posts/20160323-01.md","raw":"---\ntitle: Android studio解决gradle下载慢的问题\ndate: 2016-03-23 20:10:12\ntags: 软件使用\ncategories: 软件使用\n\n---\n\ngradle下载被墙是个很恶心的事情，半天构建不出来，所以解决下载慢，要不翻墙，要不只能引用一些国内的景象库来构建。我选择使用shadowsocks走代理的方法，shadowsocks怎么用我不再赘述，假设你已经配置好了shadowsocks并已经在浏览器中可以成功运行了。\n\n那只需在Android studio中，setting 的 http proxy下。如图配置即可\n\n{% asset_img example.jpg This is an example image %}","slug":"20160323-01","published":1,"updated":"2016-03-23T12:18:38.456Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cindau1wh000c30xgr6u3j0jk","content":"<p>gradle下载被墙是个很恶心的事情，半天构建不出来，所以解决下载慢，要不翻墙，要不只能引用一些国内的景象库来构建。我选择使用shadowsocks走代理的方法，shadowsocks怎么用我不再赘述，假设你已经配置好了shadowsocks并已经在浏览器中可以成功运行了。</p>\n<p>那只需在Android studio中，setting 的 http proxy下。如图配置即可</p>\n<img src=\"/2016/03/23/20160323-01/example.jpg\" alt=\"This is an example image\" title=\"This is an example image\">","excerpt":"","more":"<p>gradle下载被墙是个很恶心的事情，半天构建不出来，所以解决下载慢，要不翻墙，要不只能引用一些国内的景象库来构建。我选择使用shadowsocks走代理的方法，shadowsocks怎么用我不再赘述，假设你已经配置好了shadowsocks并已经在浏览器中可以成功运行了。</p>\n<p>那只需在Android studio中，setting 的 http proxy下。如图配置即可</p>\n<img src=\"/2016/03/23/20160323-01/example.jpg\" alt=\"This is an example image\" title=\"This is an example image\">"},{"title":"图片异步加载","date":"2016-03-24T13:22:51.000Z","_content":"\n当我们安卓系统要去加载一大堆的图片的时候，情况会变得比较复杂，很容易出现OOM内存溢出。为了保证不发生这种情况，通常会进行垃圾回收，但是同时也要考虑重新滑回图片时的情况，所以基于此，必须使用好内存缓存技术。\n\n根据资料，以往我们可能会使用软引用技术去处理，不过现在我们不推荐使用那个了。现在谷歌有LruCache这个核心类并且已经加入到了v4包里面，这个类很适合用来缓存图片。\n\n这里还要来讲几个东西。\n#### LinkedHashMap\n继承了HashMap，但同时他也是个双向链表，具有可预知的迭代顺序。其数组中的保存元素Entry除了保存对象引用之外，还保存了上一个元素before和下一个元素after。其提取有两种顺序，一种是按照访问顺序提取，一种是按照插入顺序提取。很适合用于LRU缓存机制。\n\n#### LRU缓存机制\nLRU是Least Recently Used 的缩写，翻译过来就是“最近最少使用”，也就是说，LRU缓存把最近最少使用的数据移除，让给最新读取的数据。而往往最常读取的，也是读取次数最多的，所以，利用LRU缓存，我们能够提高系统的performance.\n\n要实现LRU缓存，我们首先要用到一个类 LinkedHashMap。 用这个类有两大好处：一是它本身已经实现了按照访问顺序的存储，也就是说，最近读取的会放在最前面，最最不常读取的会放在最后（当然，它也可以实现按照插入顺序存储）。第二，LinkedHashMap本身有一个方法用于判断是否需要移除最不常读取的数\n\n因此我们指导安卓里的LruCache这个核心类就是基于LinkedHashMap实现的。\n","source":"_posts/20160324-03.md","raw":"---\ntitle: 图片异步加载\ndate: 2016-03-24 21:22:51\ntags: Android\ncategories: Android\n\n---\n\n当我们安卓系统要去加载一大堆的图片的时候，情况会变得比较复杂，很容易出现OOM内存溢出。为了保证不发生这种情况，通常会进行垃圾回收，但是同时也要考虑重新滑回图片时的情况，所以基于此，必须使用好内存缓存技术。\n\n根据资料，以往我们可能会使用软引用技术去处理，不过现在我们不推荐使用那个了。现在谷歌有LruCache这个核心类并且已经加入到了v4包里面，这个类很适合用来缓存图片。\n\n这里还要来讲几个东西。\n#### LinkedHashMap\n继承了HashMap，但同时他也是个双向链表，具有可预知的迭代顺序。其数组中的保存元素Entry除了保存对象引用之外，还保存了上一个元素before和下一个元素after。其提取有两种顺序，一种是按照访问顺序提取，一种是按照插入顺序提取。很适合用于LRU缓存机制。\n\n#### LRU缓存机制\nLRU是Least Recently Used 的缩写，翻译过来就是“最近最少使用”，也就是说，LRU缓存把最近最少使用的数据移除，让给最新读取的数据。而往往最常读取的，也是读取次数最多的，所以，利用LRU缓存，我们能够提高系统的performance.\n\n要实现LRU缓存，我们首先要用到一个类 LinkedHashMap。 用这个类有两大好处：一是它本身已经实现了按照访问顺序的存储，也就是说，最近读取的会放在最前面，最最不常读取的会放在最后（当然，它也可以实现按照插入顺序存储）。第二，LinkedHashMap本身有一个方法用于判断是否需要移除最不常读取的数\n\n因此我们指导安卓里的LruCache这个核心类就是基于LinkedHashMap实现的。\n","slug":"20160324-03","published":1,"updated":"2016-03-24T14:41:17.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cindau1wl000f30xgy2rq0oxs","content":"<p>当我们安卓系统要去加载一大堆的图片的时候，情况会变得比较复杂，很容易出现OOM内存溢出。为了保证不发生这种情况，通常会进行垃圾回收，但是同时也要考虑重新滑回图片时的情况，所以基于此，必须使用好内存缓存技术。</p>\n<p>根据资料，以往我们可能会使用软引用技术去处理，不过现在我们不推荐使用那个了。现在谷歌有LruCache这个核心类并且已经加入到了v4包里面，这个类很适合用来缓存图片。</p>\n<p>这里还要来讲几个东西。</p>\n<h4 id=\"LinkedHashMap\"><a href=\"#LinkedHashMap\" class=\"headerlink\" title=\"LinkedHashMap\"></a>LinkedHashMap</h4><p>继承了HashMap，但同时他也是个双向链表，具有可预知的迭代顺序。其数组中的保存元素Entry除了保存对象引用之外，还保存了上一个元素before和下一个元素after。其提取有两种顺序，一种是按照访问顺序提取，一种是按照插入顺序提取。很适合用于LRU缓存机制。</p>\n<h4 id=\"LRU缓存机制\"><a href=\"#LRU缓存机制\" class=\"headerlink\" title=\"LRU缓存机制\"></a>LRU缓存机制</h4><p>LRU是Least Recently Used 的缩写，翻译过来就是“最近最少使用”，也就是说，LRU缓存把最近最少使用的数据移除，让给最新读取的数据。而往往最常读取的，也是读取次数最多的，所以，利用LRU缓存，我们能够提高系统的performance.</p>\n<p>要实现LRU缓存，我们首先要用到一个类 LinkedHashMap。 用这个类有两大好处：一是它本身已经实现了按照访问顺序的存储，也就是说，最近读取的会放在最前面，最最不常读取的会放在最后（当然，它也可以实现按照插入顺序存储）。第二，LinkedHashMap本身有一个方法用于判断是否需要移除最不常读取的数</p>\n<p>因此我们指导安卓里的LruCache这个核心类就是基于LinkedHashMap实现的。</p>\n","excerpt":"","more":"<p>当我们安卓系统要去加载一大堆的图片的时候，情况会变得比较复杂，很容易出现OOM内存溢出。为了保证不发生这种情况，通常会进行垃圾回收，但是同时也要考虑重新滑回图片时的情况，所以基于此，必须使用好内存缓存技术。</p>\n<p>根据资料，以往我们可能会使用软引用技术去处理，不过现在我们不推荐使用那个了。现在谷歌有LruCache这个核心类并且已经加入到了v4包里面，这个类很适合用来缓存图片。</p>\n<p>这里还要来讲几个东西。</p>\n<h4 id=\"LinkedHashMap\"><a href=\"#LinkedHashMap\" class=\"headerlink\" title=\"LinkedHashMap\"></a>LinkedHashMap</h4><p>继承了HashMap，但同时他也是个双向链表，具有可预知的迭代顺序。其数组中的保存元素Entry除了保存对象引用之外，还保存了上一个元素before和下一个元素after。其提取有两种顺序，一种是按照访问顺序提取，一种是按照插入顺序提取。很适合用于LRU缓存机制。</p>\n<h4 id=\"LRU缓存机制\"><a href=\"#LRU缓存机制\" class=\"headerlink\" title=\"LRU缓存机制\"></a>LRU缓存机制</h4><p>LRU是Least Recently Used 的缩写，翻译过来就是“最近最少使用”，也就是说，LRU缓存把最近最少使用的数据移除，让给最新读取的数据。而往往最常读取的，也是读取次数最多的，所以，利用LRU缓存，我们能够提高系统的performance.</p>\n<p>要实现LRU缓存，我们首先要用到一个类 LinkedHashMap。 用这个类有两大好处：一是它本身已经实现了按照访问顺序的存储，也就是说，最近读取的会放在最前面，最最不常读取的会放在最后（当然，它也可以实现按照插入顺序存储）。第二，LinkedHashMap本身有一个方法用于判断是否需要移除最不常读取的数</p>\n<p>因此我们指导安卓里的LruCache这个核心类就是基于LinkedHashMap实现的。</p>\n"},{"title":"java泛型的一些理解与笔记","date":"2016-03-24T10:15:09.000Z","_content":"\n都知道ArrayList是基于List接口实现的，HashMap是基于Map接口实现的。我们在编程的时候都尽量用List和Map来定义变量，这样就实现了面相接口编程，修改的时候也更加灵活。\n\n现在来说说HashMap，它是map类的实现，当它接受一个key-value键值对的时候，它会把key对象做hashcode处理，hashCode()是每个Object都具备的方法，hashcode计算出来后用与作存储位置，而对应的value存在那个地方即可。这就是hashMap的简单原理。\n\n在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。 当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键，而应该用containsKey()方法来判断。而在Hashtable中，无论是key还是value都不能为null 。","source":"_posts/20160324-01.md","raw":"---\ntitle: java泛型的一些理解与笔记\ndate: 2016-03-24 18:15:09\ntags: java\ncategories: java\n\n---\n\n都知道ArrayList是基于List接口实现的，HashMap是基于Map接口实现的。我们在编程的时候都尽量用List和Map来定义变量，这样就实现了面相接口编程，修改的时候也更加灵活。\n\n现在来说说HashMap，它是map类的实现，当它接受一个key-value键值对的时候，它会把key对象做hashcode处理，hashCode()是每个Object都具备的方法，hashcode计算出来后用与作存储位置，而对应的value存在那个地方即可。这就是hashMap的简单原理。\n\n在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。 当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键，而应该用containsKey()方法来判断。而在Hashtable中，无论是key还是value都不能为null 。","slug":"20160324-01","published":1,"updated":"2016-03-24T14:19:58.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cindau1wq000j30xgwh5fbta4","content":"<p>都知道ArrayList是基于List接口实现的，HashMap是基于Map接口实现的。我们在编程的时候都尽量用List和Map来定义变量，这样就实现了面相接口编程，修改的时候也更加灵活。</p>\n<p>现在来说说HashMap，它是map类的实现，当它接受一个key-value键值对的时候，它会把key对象做hashcode处理，hashCode()是每个Object都具备的方法，hashcode计算出来后用与作存储位置，而对应的value存在那个地方即可。这就是hashMap的简单原理。</p>\n<p>在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。 当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键，而应该用containsKey()方法来判断。而在Hashtable中，无论是key还是value都不能为null 。</p>\n","excerpt":"","more":"<p>都知道ArrayList是基于List接口实现的，HashMap是基于Map接口实现的。我们在编程的时候都尽量用List和Map来定义变量，这样就实现了面相接口编程，修改的时候也更加灵活。</p>\n<p>现在来说说HashMap，它是map类的实现，当它接受一个key-value键值对的时候，它会把key对象做hashcode处理，hashCode()是每个Object都具备的方法，hashcode计算出来后用与作存储位置，而对应的value存在那个地方即可。这就是hashMap的简单原理。</p>\n<p>在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。 当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键，而应该用containsKey()方法来判断。而在Hashtable中，无论是key还是value都不能为null 。</p>\n"},{"title":"java虚拟机笔记(1) java内存区域","date":"2016-04-08T14:14:37.000Z","_content":"\n## 运行时数据区域\n\njava虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。\n\n\n{% asset_img memory.jpg This is an example image %}\n\n### 程序计数器\n程序计数器是一个较小的内存空间，当前线程的字节码指示器，工作时通过改变这个计数器的值选取下一条需要执行的字节码指令\n\n每隔线程都需要一个独立的程序计数器，各线程互不影响，这块内存为**线程私有内存**\n\n此区域是唯一一在java虚拟机规范中没有规定任何OOM情况的区域\n\n### java虚拟机栈\n线程私有，生命周期与线程相同。每个方法在执行时都会创建一个栈帧(Stack Frame),用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每个方法调用到执行完成的过程对应这一个栈帧在虚拟机栈中入栈到出栈。\n\n局部变量表里存放了编译期可知的各种基本数据类型(boolean byte char short int float double long)还有对象引用(reference)\n\n当进入一个方法时，这个方法需要在帧中分配多大的局部空间是完全确定的，在方法运行期间不会改变局部变量表的大小。\n\n在java虚拟机规范中，如果线程请求栈深度大于虚拟机允许的深度，将抛出StackOverFlow异常，无法申请到足够内存，将会抛出OutOfMemory异常。\n\n### 本地方法栈\n和虚拟机栈功能十分相似，虚拟机栈为执行java方法服务，本地方法栈则为虚拟机使用到的native方法服务。与虚拟机栈一样，会抛出栈溢出和OOM错误。\n\n### java堆\njava虚拟机中管理内存最大的一块，被所有线程共享。此区唯一的目的就是存放对象实例，几乎所有实例对象和数组都在这里分配内存。\n\njava堆是垃圾收集器管理的主要区域。从内存分配的角度看，还可能分出线程私有的分配缓冲区。java堆可以分配在物理上不连续的内存空间中，但逻辑上是连续的。当堆再也无法扩展时，抛出OOM异常。\n\n### 方法区\n和堆一样是各个线程共享去内存区域。用以存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码数据。有个别名为Non-Heap\n\n方法区无法满足内存分配时也会抛出OOM\n\n方法区中有一部分为运行时常量池，用于存放编译器生成的各种字面量和符号引用。\n\n>以上笔记均摘抄自*深入理解java虚拟机-jvm高级特性与最佳实践* \n>\n>这是一本非常棒的书，值得一看","source":"_posts/20160408-01.md","raw":"---\ntitle: java虚拟机笔记(1) java内存区域\ndate: 2016-04-08 22:14:37\ntags: \n - java \n - java虚拟机\ncategories: java\n\n---\n\n## 运行时数据区域\n\njava虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。\n\n\n{% asset_img memory.jpg This is an example image %}\n\n### 程序计数器\n程序计数器是一个较小的内存空间，当前线程的字节码指示器，工作时通过改变这个计数器的值选取下一条需要执行的字节码指令\n\n每隔线程都需要一个独立的程序计数器，各线程互不影响，这块内存为**线程私有内存**\n\n此区域是唯一一在java虚拟机规范中没有规定任何OOM情况的区域\n\n### java虚拟机栈\n线程私有，生命周期与线程相同。每个方法在执行时都会创建一个栈帧(Stack Frame),用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每个方法调用到执行完成的过程对应这一个栈帧在虚拟机栈中入栈到出栈。\n\n局部变量表里存放了编译期可知的各种基本数据类型(boolean byte char short int float double long)还有对象引用(reference)\n\n当进入一个方法时，这个方法需要在帧中分配多大的局部空间是完全确定的，在方法运行期间不会改变局部变量表的大小。\n\n在java虚拟机规范中，如果线程请求栈深度大于虚拟机允许的深度，将抛出StackOverFlow异常，无法申请到足够内存，将会抛出OutOfMemory异常。\n\n### 本地方法栈\n和虚拟机栈功能十分相似，虚拟机栈为执行java方法服务，本地方法栈则为虚拟机使用到的native方法服务。与虚拟机栈一样，会抛出栈溢出和OOM错误。\n\n### java堆\njava虚拟机中管理内存最大的一块，被所有线程共享。此区唯一的目的就是存放对象实例，几乎所有实例对象和数组都在这里分配内存。\n\njava堆是垃圾收集器管理的主要区域。从内存分配的角度看，还可能分出线程私有的分配缓冲区。java堆可以分配在物理上不连续的内存空间中，但逻辑上是连续的。当堆再也无法扩展时，抛出OOM异常。\n\n### 方法区\n和堆一样是各个线程共享去内存区域。用以存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码数据。有个别名为Non-Heap\n\n方法区无法满足内存分配时也会抛出OOM\n\n方法区中有一部分为运行时常量池，用于存放编译器生成的各种字面量和符号引用。\n\n>以上笔记均摘抄自*深入理解java虚拟机-jvm高级特性与最佳实践* \n>\n>这是一本非常棒的书，值得一看","slug":"20160408-01","published":1,"updated":"2016-04-08T16:28:21.177Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cindau1wt000m30xgflgmvg7x","content":"<h2 id=\"运行时数据区域\"><a href=\"#运行时数据区域\" class=\"headerlink\" title=\"运行时数据区域\"></a>运行时数据区域</h2><p>java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。</p>\n<img src=\"/2016/04/08/20160408-01/memory.jpg\" alt=\"This is an example image\" title=\"This is an example image\">\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>程序计数器是一个较小的内存空间，当前线程的字节码指示器，工作时通过改变这个计数器的值选取下一条需要执行的字节码指令</p>\n<p>每隔线程都需要一个独立的程序计数器，各线程互不影响，这块内存为<strong>线程私有内存</strong></p>\n<p>此区域是唯一一在java虚拟机规范中没有规定任何OOM情况的区域</p>\n<h3 id=\"java虚拟机栈\"><a href=\"#java虚拟机栈\" class=\"headerlink\" title=\"java虚拟机栈\"></a>java虚拟机栈</h3><p>线程私有，生命周期与线程相同。每个方法在执行时都会创建一个栈帧(Stack Frame),用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每个方法调用到执行完成的过程对应这一个栈帧在虚拟机栈中入栈到出栈。</p>\n<p>局部变量表里存放了编译期可知的各种基本数据类型(boolean byte char short int float double long)还有对象引用(reference)</p>\n<p>当进入一个方法时，这个方法需要在帧中分配多大的局部空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>\n<p>在java虚拟机规范中，如果线程请求栈深度大于虚拟机允许的深度，将抛出StackOverFlow异常，无法申请到足够内存，将会抛出OutOfMemory异常。</p>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>和虚拟机栈功能十分相似，虚拟机栈为执行java方法服务，本地方法栈则为虚拟机使用到的native方法服务。与虚拟机栈一样，会抛出栈溢出和OOM错误。</p>\n<h3 id=\"java堆\"><a href=\"#java堆\" class=\"headerlink\" title=\"java堆\"></a>java堆</h3><p>java虚拟机中管理内存最大的一块，被所有线程共享。此区唯一的目的就是存放对象实例，几乎所有实例对象和数组都在这里分配内存。</p>\n<p>java堆是垃圾收集器管理的主要区域。从内存分配的角度看，还可能分出线程私有的分配缓冲区。java堆可以分配在物理上不连续的内存空间中，但逻辑上是连续的。当堆再也无法扩展时，抛出OOM异常。</p>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h3><p>和堆一样是各个线程共享去内存区域。用以存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码数据。有个别名为Non-Heap</p>\n<p>方法区无法满足内存分配时也会抛出OOM</p>\n<p>方法区中有一部分为运行时常量池，用于存放编译器生成的各种字面量和符号引用。</p>\n<blockquote>\n<p>以上笔记均摘抄自<em>深入理解java虚拟机-jvm高级特性与最佳实践</em> </p>\n<p>这是一本非常棒的书，值得一看</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"运行时数据区域\"><a href=\"#运行时数据区域\" class=\"headerlink\" title=\"运行时数据区域\"></a>运行时数据区域</h2><p>java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。</p>\n<img src=\"/2016/04/08/20160408-01/memory.jpg\" alt=\"This is an example image\" title=\"This is an example image\">\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>程序计数器是一个较小的内存空间，当前线程的字节码指示器，工作时通过改变这个计数器的值选取下一条需要执行的字节码指令</p>\n<p>每隔线程都需要一个独立的程序计数器，各线程互不影响，这块内存为<strong>线程私有内存</strong></p>\n<p>此区域是唯一一在java虚拟机规范中没有规定任何OOM情况的区域</p>\n<h3 id=\"java虚拟机栈\"><a href=\"#java虚拟机栈\" class=\"headerlink\" title=\"java虚拟机栈\"></a>java虚拟机栈</h3><p>线程私有，生命周期与线程相同。每个方法在执行时都会创建一个栈帧(Stack Frame),用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每个方法调用到执行完成的过程对应这一个栈帧在虚拟机栈中入栈到出栈。</p>\n<p>局部变量表里存放了编译期可知的各种基本数据类型(boolean byte char short int float double long)还有对象引用(reference)</p>\n<p>当进入一个方法时，这个方法需要在帧中分配多大的局部空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>\n<p>在java虚拟机规范中，如果线程请求栈深度大于虚拟机允许的深度，将抛出StackOverFlow异常，无法申请到足够内存，将会抛出OutOfMemory异常。</p>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>和虚拟机栈功能十分相似，虚拟机栈为执行java方法服务，本地方法栈则为虚拟机使用到的native方法服务。与虚拟机栈一样，会抛出栈溢出和OOM错误。</p>\n<h3 id=\"java堆\"><a href=\"#java堆\" class=\"headerlink\" title=\"java堆\"></a>java堆</h3><p>java虚拟机中管理内存最大的一块，被所有线程共享。此区唯一的目的就是存放对象实例，几乎所有实例对象和数组都在这里分配内存。</p>\n<p>java堆是垃圾收集器管理的主要区域。从内存分配的角度看，还可能分出线程私有的分配缓冲区。java堆可以分配在物理上不连续的内存空间中，但逻辑上是连续的。当堆再也无法扩展时，抛出OOM异常。</p>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h3><p>和堆一样是各个线程共享去内存区域。用以存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码数据。有个别名为Non-Heap</p>\n<p>方法区无法满足内存分配时也会抛出OOM</p>\n<p>方法区中有一部分为运行时常量池，用于存放编译器生成的各种字面量和符号引用。</p>\n<blockquote>\n<p>以上笔记均摘抄自<em>深入理解java虚拟机-jvm高级特性与最佳实践</em> </p>\n<p>这是一本非常棒的书，值得一看</p>\n</blockquote>\n"},{"title":"java虚拟机笔记(2) 垃圾回收器与内存分配","date":"2016-04-08T16:34:27.000Z","_content":"## 判断对象已死\n\n### 引用计数器算法\n\n比较典型的教科书算法是引用计数算法，每当有地方引用则计数器加一，没有地方引用则计数器减一，清0则被gc回收。\n\n然而实际上并不采用这种方法回收，虽然COM技术，Python这些是用这个方法。但是jvm并没有采用，他很难解决对象之间相互引用的问题。\n\n``` java\npublic class ref{\n  Object instance = null\n}\n\n```\n\n好比上面定义的类，如果实例化A和B，A.instance指向B，B的指向A，则最后无法被垃圾回收。所以jvm不采用这种方法\n\n### 可达性算法\n类似JAVA C#的主流实现都是采用可达性分析。算法基本思路即是通过一系列“GC ROOTs”对象做为起点搜索，当一个对象到GC Roots没有任何引用链相连时证明此对象不可用。\n\n一个对象要真正被宣告死亡，至少经过两次标记。第一次标记后进行筛选，看是否有必要执行finalize()方法，对象未覆盖此方法或者已经被调用过则视为没有必要执行，否则执行finalize方法。如果被判定为没有必要执行，则进入F-Queue队列等待虚拟机调用自动建立的Finalizer线程执行它。稍后在GC中将对F-Queue中的对象进行第二次标记，第二次标记时它将可能被移出逃脱，如果未能在之前逃脱则基本是要被回收了。\n\n## 垃圾回收算法\n\n### 标记-清除算法\n标记出回收对象，标记完成后统一回收。有两个主要不足，一是标记和清除效率都不高，二是容易产生大量不连续内存的碎片。\n\n### 复制算法\n将内存分为等大小两块，一块用完了，复制存活对象到另外一块上，清除原来的内存块。但是代价是内存缩小一半\n\n现代虚拟机基本采用这种算法回收新生代，新生代对象朝生夕死，因此可以将内存分为较大的Eden空间和两个较小的Survivor空间，每次使用Eden和其中一块Survivor，讲Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上。默认Eden:Survivor为8:1，虽然每次只有10%的内存被浪费，但是缺点是如果每次的存活对象超过十分之一就不行了。因此Survivor空间不够是要其他内存(老年代)进行分配担保\n\n复制收集算法在对象存活率高时要经常复制，效率会变低\n\n### 标记整理算法\n老年代一般采用这种算法，标记完对象后不直接清除，让存活对象向一端移动，然后直接清除边界以外的内存。\n\n## 总结\n商业虚拟机都是分代收集，一般是把java堆分成新生代和老年代，这样可以根据各年代特点采用适合的收集算法，每次有大批对象死去的选用复制，存活率高且无额外空间的使用标记清理或者标记整理。\n\n>以上笔记均摘抄自*深入理解java虚拟机-jvm高级特性与最佳实践* \n>\n>这是一本非常棒的书，值得一看","source":"_posts/20160409-01.md","raw":"---\ntitle: java虚拟机笔记(2) 垃圾回收器与内存分配\ndate: 2016-04-09 00:34:27\ntags: \n - java\n - java虚拟机\ncategories: java\n\n---\n## 判断对象已死\n\n### 引用计数器算法\n\n比较典型的教科书算法是引用计数算法，每当有地方引用则计数器加一，没有地方引用则计数器减一，清0则被gc回收。\n\n然而实际上并不采用这种方法回收，虽然COM技术，Python这些是用这个方法。但是jvm并没有采用，他很难解决对象之间相互引用的问题。\n\n``` java\npublic class ref{\n  Object instance = null\n}\n\n```\n\n好比上面定义的类，如果实例化A和B，A.instance指向B，B的指向A，则最后无法被垃圾回收。所以jvm不采用这种方法\n\n### 可达性算法\n类似JAVA C#的主流实现都是采用可达性分析。算法基本思路即是通过一系列“GC ROOTs”对象做为起点搜索，当一个对象到GC Roots没有任何引用链相连时证明此对象不可用。\n\n一个对象要真正被宣告死亡，至少经过两次标记。第一次标记后进行筛选，看是否有必要执行finalize()方法，对象未覆盖此方法或者已经被调用过则视为没有必要执行，否则执行finalize方法。如果被判定为没有必要执行，则进入F-Queue队列等待虚拟机调用自动建立的Finalizer线程执行它。稍后在GC中将对F-Queue中的对象进行第二次标记，第二次标记时它将可能被移出逃脱，如果未能在之前逃脱则基本是要被回收了。\n\n## 垃圾回收算法\n\n### 标记-清除算法\n标记出回收对象，标记完成后统一回收。有两个主要不足，一是标记和清除效率都不高，二是容易产生大量不连续内存的碎片。\n\n### 复制算法\n将内存分为等大小两块，一块用完了，复制存活对象到另外一块上，清除原来的内存块。但是代价是内存缩小一半\n\n现代虚拟机基本采用这种算法回收新生代，新生代对象朝生夕死，因此可以将内存分为较大的Eden空间和两个较小的Survivor空间，每次使用Eden和其中一块Survivor，讲Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上。默认Eden:Survivor为8:1，虽然每次只有10%的内存被浪费，但是缺点是如果每次的存活对象超过十分之一就不行了。因此Survivor空间不够是要其他内存(老年代)进行分配担保\n\n复制收集算法在对象存活率高时要经常复制，效率会变低\n\n### 标记整理算法\n老年代一般采用这种算法，标记完对象后不直接清除，让存活对象向一端移动，然后直接清除边界以外的内存。\n\n## 总结\n商业虚拟机都是分代收集，一般是把java堆分成新生代和老年代，这样可以根据各年代特点采用适合的收集算法，每次有大批对象死去的选用复制，存活率高且无额外空间的使用标记清理或者标记整理。\n\n>以上笔记均摘抄自*深入理解java虚拟机-jvm高级特性与最佳实践* \n>\n>这是一本非常棒的书，值得一看","slug":"20160409-01","published":1,"updated":"2016-04-15T14:22:28.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cindau1wy000r30xgxe9v4lqn","content":"<h2 id=\"判断对象已死\"><a href=\"#判断对象已死\" class=\"headerlink\" title=\"判断对象已死\"></a>判断对象已死</h2><h3 id=\"引用计数器算法\"><a href=\"#引用计数器算法\" class=\"headerlink\" title=\"引用计数器算法\"></a>引用计数器算法</h3><p>比较典型的教科书算法是引用计数算法，每当有地方引用则计数器加一，没有地方引用则计数器减一，清0则被gc回收。</p>\n<p>然而实际上并不采用这种方法回收，虽然COM技术，Python这些是用这个方法。但是jvm并没有采用，他很难解决对象之间相互引用的问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ref</span></span>&#123;</span><br><span class=\"line\">  Object instance = <span class=\"keyword\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好比上面定义的类，如果实例化A和B，A.instance指向B，B的指向A，则最后无法被垃圾回收。所以jvm不采用这种方法</p>\n<h3 id=\"可达性算法\"><a href=\"#可达性算法\" class=\"headerlink\" title=\"可达性算法\"></a>可达性算法</h3><p>类似JAVA C#的主流实现都是采用可达性分析。算法基本思路即是通过一系列“GC ROOTs”对象做为起点搜索，当一个对象到GC Roots没有任何引用链相连时证明此对象不可用。</p>\n<p>一个对象要真正被宣告死亡，至少经过两次标记。第一次标记后进行筛选，看是否有必要执行finalize()方法，对象未覆盖此方法或者已经被调用过则视为没有必要执行，否则执行finalize方法。如果被判定为没有必要执行，则进入F-Queue队列等待虚拟机调用自动建立的Finalizer线程执行它。稍后在GC中将对F-Queue中的对象进行第二次标记，第二次标记时它将可能被移出逃脱，如果未能在之前逃脱则基本是要被回收了。</p>\n<h2 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h2><h3 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h3><p>标记出回收对象，标记完成后统一回收。有两个主要不足，一是标记和清除效率都不高，二是容易产生大量不连续内存的碎片。</p>\n<h3 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h3><p>将内存分为等大小两块，一块用完了，复制存活对象到另外一块上，清除原来的内存块。但是代价是内存缩小一半</p>\n<p>现代虚拟机基本采用这种算法回收新生代，新生代对象朝生夕死，因此可以将内存分为较大的Eden空间和两个较小的Survivor空间，每次使用Eden和其中一块Survivor，讲Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上。默认Eden:Survivor为8:1，虽然每次只有10%的内存被浪费，但是缺点是如果每次的存活对象超过十分之一就不行了。因此Survivor空间不够是要其他内存(老年代)进行分配担保</p>\n<p>复制收集算法在对象存活率高时要经常复制，效率会变低</p>\n<h3 id=\"标记整理算法\"><a href=\"#标记整理算法\" class=\"headerlink\" title=\"标记整理算法\"></a>标记整理算法</h3><p>老年代一般采用这种算法，标记完对象后不直接清除，让存活对象向一端移动，然后直接清除边界以外的内存。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>商业虚拟机都是分代收集，一般是把java堆分成新生代和老年代，这样可以根据各年代特点采用适合的收集算法，每次有大批对象死去的选用复制，存活率高且无额外空间的使用标记清理或者标记整理。</p>\n<blockquote>\n<p>以上笔记均摘抄自<em>深入理解java虚拟机-jvm高级特性与最佳实践</em> </p>\n<p>这是一本非常棒的书，值得一看</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"判断对象已死\"><a href=\"#判断对象已死\" class=\"headerlink\" title=\"判断对象已死\"></a>判断对象已死</h2><h3 id=\"引用计数器算法\"><a href=\"#引用计数器算法\" class=\"headerlink\" title=\"引用计数器算法\"></a>引用计数器算法</h3><p>比较典型的教科书算法是引用计数算法，每当有地方引用则计数器加一，没有地方引用则计数器减一，清0则被gc回收。</p>\n<p>然而实际上并不采用这种方法回收，虽然COM技术，Python这些是用这个方法。但是jvm并没有采用，他很难解决对象之间相互引用的问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ref</span></span>&#123;</span><br><span class=\"line\">  Object instance = <span class=\"keyword\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好比上面定义的类，如果实例化A和B，A.instance指向B，B的指向A，则最后无法被垃圾回收。所以jvm不采用这种方法</p>\n<h3 id=\"可达性算法\"><a href=\"#可达性算法\" class=\"headerlink\" title=\"可达性算法\"></a>可达性算法</h3><p>类似JAVA C#的主流实现都是采用可达性分析。算法基本思路即是通过一系列“GC ROOTs”对象做为起点搜索，当一个对象到GC Roots没有任何引用链相连时证明此对象不可用。</p>\n<p>一个对象要真正被宣告死亡，至少经过两次标记。第一次标记后进行筛选，看是否有必要执行finalize()方法，对象未覆盖此方法或者已经被调用过则视为没有必要执行，否则执行finalize方法。如果被判定为没有必要执行，则进入F-Queue队列等待虚拟机调用自动建立的Finalizer线程执行它。稍后在GC中将对F-Queue中的对象进行第二次标记，第二次标记时它将可能被移出逃脱，如果未能在之前逃脱则基本是要被回收了。</p>\n<h2 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h2><h3 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h3><p>标记出回收对象，标记完成后统一回收。有两个主要不足，一是标记和清除效率都不高，二是容易产生大量不连续内存的碎片。</p>\n<h3 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h3><p>将内存分为等大小两块，一块用完了，复制存活对象到另外一块上，清除原来的内存块。但是代价是内存缩小一半</p>\n<p>现代虚拟机基本采用这种算法回收新生代，新生代对象朝生夕死，因此可以将内存分为较大的Eden空间和两个较小的Survivor空间，每次使用Eden和其中一块Survivor，讲Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上。默认Eden:Survivor为8:1，虽然每次只有10%的内存被浪费，但是缺点是如果每次的存活对象超过十分之一就不行了。因此Survivor空间不够是要其他内存(老年代)进行分配担保</p>\n<p>复制收集算法在对象存活率高时要经常复制，效率会变低</p>\n<h3 id=\"标记整理算法\"><a href=\"#标记整理算法\" class=\"headerlink\" title=\"标记整理算法\"></a>标记整理算法</h3><p>老年代一般采用这种算法，标记完对象后不直接清除，让存活对象向一端移动，然后直接清除边界以外的内存。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>商业虚拟机都是分代收集，一般是把java堆分成新生代和老年代，这样可以根据各年代特点采用适合的收集算法，每次有大批对象死去的选用复制，存活率高且无额外空间的使用标记清理或者标记整理。</p>\n<blockquote>\n<p>以上笔记均摘抄自<em>深入理解java虚拟机-jvm高级特性与最佳实践</em> </p>\n<p>这是一本非常棒的书，值得一看</p>\n</blockquote>\n"},{"title":"java里的可达性和各种引用","date":"2016-03-24T12:17:39.000Z","_content":"\n最近在学习Android中遇到了图片加载内存溢出的问题，所以顺便学习java虚拟机里的一些内存回收机制。\n\n### 可达性\njava虚拟机中有五个级别的可达性。\n\n - 强可达\n\n强可达所使用的对象，通常而言不会被GC回收。那些直接被new出来使用的对象就是强可达， 一个对象可以被一些线程直接使用而不通过其他引用对象，就是强可达。\n\n - 软可达\n\n>  如果一个对象没有强可达性，但是它可以通过一个软引用(soft reference.)来使用，那么它就具有软可达性。只有当系统需要更多内存时，GC才会回收具有软可达性的对象。在内存不足前，GC保证一定回收软可达的对象。\n\n就是说，软引用对象的回收去决定于不同版本JVM的回收机制，回收之后软引用会返回null。\n\n - 弱可达\n\n> 如果一个对象既没有强可达性，也没有软可达性，但是它可以通过一个弱引用(weak reference)来使用，那么他就具有弱可达性。当弱引用指向的弱可达对象没有其他的引用，那么这个对象就会被回收。\n\n - 虚可达\n>如果一个对象既没有强可达性，也没有软可达性、弱可达性，他已经被终结（finalized），并且有一些虚引用（phantom reference）指向它，那么它就具有虚可达性。\n\n就是说虚引用指向的对象已经被终结了，永远返回null。\n\n - 不可达\n>当一个对象不能通过以上的方式指向，那么这个对象就变得不可达，并因此适合被回收。\n\n\n### 引用的类型\nJDK1.2之后，对象引用被分为四个级别。\n\n - 强引用\n\n垃圾回收器不回收强引用，如若内存空间不足，jvm将会OOM错误。\n\n - 软引用\n\n够空间就不回收，不够就回。可用于实现内存敏感的高速缓存\n\n - 弱引用\n\n对象若是有弱引用，那将具有更短的生命周期，一旦它被扫描到，不管内存空间是否充足都会被回收，不过由于垃圾回收器是个级别很低的线程，所以不一定会很快发现弱引用对象。\n\n - 虚引用\n\n形同虚设，并不决定对象生命周期，主要用来跟踪对象被GC回收的活动。\n\n","source":"_posts/20160324-02.md","raw":"---\ntitle: java里的可达性和各种引用\ndate: 2016-03-24 20:17:39\ntags: java\ncategories: java\n\n---\n\n最近在学习Android中遇到了图片加载内存溢出的问题，所以顺便学习java虚拟机里的一些内存回收机制。\n\n### 可达性\njava虚拟机中有五个级别的可达性。\n\n - 强可达\n\n强可达所使用的对象，通常而言不会被GC回收。那些直接被new出来使用的对象就是强可达， 一个对象可以被一些线程直接使用而不通过其他引用对象，就是强可达。\n\n - 软可达\n\n>  如果一个对象没有强可达性，但是它可以通过一个软引用(soft reference.)来使用，那么它就具有软可达性。只有当系统需要更多内存时，GC才会回收具有软可达性的对象。在内存不足前，GC保证一定回收软可达的对象。\n\n就是说，软引用对象的回收去决定于不同版本JVM的回收机制，回收之后软引用会返回null。\n\n - 弱可达\n\n> 如果一个对象既没有强可达性，也没有软可达性，但是它可以通过一个弱引用(weak reference)来使用，那么他就具有弱可达性。当弱引用指向的弱可达对象没有其他的引用，那么这个对象就会被回收。\n\n - 虚可达\n>如果一个对象既没有强可达性，也没有软可达性、弱可达性，他已经被终结（finalized），并且有一些虚引用（phantom reference）指向它，那么它就具有虚可达性。\n\n就是说虚引用指向的对象已经被终结了，永远返回null。\n\n - 不可达\n>当一个对象不能通过以上的方式指向，那么这个对象就变得不可达，并因此适合被回收。\n\n\n### 引用的类型\nJDK1.2之后，对象引用被分为四个级别。\n\n - 强引用\n\n垃圾回收器不回收强引用，如若内存空间不足，jvm将会OOM错误。\n\n - 软引用\n\n够空间就不回收，不够就回。可用于实现内存敏感的高速缓存\n\n - 弱引用\n\n对象若是有弱引用，那将具有更短的生命周期，一旦它被扫描到，不管内存空间是否充足都会被回收，不过由于垃圾回收器是个级别很低的线程，所以不一定会很快发现弱引用对象。\n\n - 虚引用\n\n形同虚设，并不决定对象生命周期，主要用来跟踪对象被GC回收的活动。\n\n","slug":"20160324-02","published":1,"updated":"2016-03-29T12:39:46.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cindau1x0000u30xgujjftqze","content":"<p>最近在学习Android中遇到了图片加载内存溢出的问题，所以顺便学习java虚拟机里的一些内存回收机制。</p>\n<h3 id=\"可达性\"><a href=\"#可达性\" class=\"headerlink\" title=\"可达性\"></a>可达性</h3><p>java虚拟机中有五个级别的可达性。</p>\n<ul>\n<li>强可达</li>\n</ul>\n<p>强可达所使用的对象，通常而言不会被GC回收。那些直接被new出来使用的对象就是强可达， 一个对象可以被一些线程直接使用而不通过其他引用对象，就是强可达。</p>\n<ul>\n<li>软可达</li>\n</ul>\n<blockquote>\n<p> 如果一个对象没有强可达性，但是它可以通过一个软引用(soft reference.)来使用，那么它就具有软可达性。只有当系统需要更多内存时，GC才会回收具有软可达性的对象。在内存不足前，GC保证一定回收软可达的对象。</p>\n</blockquote>\n<p>就是说，软引用对象的回收去决定于不同版本JVM的回收机制，回收之后软引用会返回null。</p>\n<ul>\n<li>弱可达</li>\n</ul>\n<blockquote>\n<p>如果一个对象既没有强可达性，也没有软可达性，但是它可以通过一个弱引用(weak reference)来使用，那么他就具有弱可达性。当弱引用指向的弱可达对象没有其他的引用，那么这个对象就会被回收。</p>\n</blockquote>\n<ul>\n<li>虚可达<blockquote>\n<p>如果一个对象既没有强可达性，也没有软可达性、弱可达性，他已经被终结（finalized），并且有一些虚引用（phantom reference）指向它，那么它就具有虚可达性。</p>\n</blockquote>\n</li>\n</ul>\n<p>就是说虚引用指向的对象已经被终结了，永远返回null。</p>\n<ul>\n<li>不可达<blockquote>\n<p>当一个对象不能通过以上的方式指向，那么这个对象就变得不可达，并因此适合被回收。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"引用的类型\"><a href=\"#引用的类型\" class=\"headerlink\" title=\"引用的类型\"></a>引用的类型</h3><p>JDK1.2之后，对象引用被分为四个级别。</p>\n<ul>\n<li>强引用</li>\n</ul>\n<p>垃圾回收器不回收强引用，如若内存空间不足，jvm将会OOM错误。</p>\n<ul>\n<li>软引用</li>\n</ul>\n<p>够空间就不回收，不够就回。可用于实现内存敏感的高速缓存</p>\n<ul>\n<li>弱引用</li>\n</ul>\n<p>对象若是有弱引用，那将具有更短的生命周期，一旦它被扫描到，不管内存空间是否充足都会被回收，不过由于垃圾回收器是个级别很低的线程，所以不一定会很快发现弱引用对象。</p>\n<ul>\n<li>虚引用</li>\n</ul>\n<p>形同虚设，并不决定对象生命周期，主要用来跟踪对象被GC回收的活动。</p>\n","excerpt":"","more":"<p>最近在学习Android中遇到了图片加载内存溢出的问题，所以顺便学习java虚拟机里的一些内存回收机制。</p>\n<h3 id=\"可达性\"><a href=\"#可达性\" class=\"headerlink\" title=\"可达性\"></a>可达性</h3><p>java虚拟机中有五个级别的可达性。</p>\n<ul>\n<li>强可达</li>\n</ul>\n<p>强可达所使用的对象，通常而言不会被GC回收。那些直接被new出来使用的对象就是强可达， 一个对象可以被一些线程直接使用而不通过其他引用对象，就是强可达。</p>\n<ul>\n<li>软可达</li>\n</ul>\n<blockquote>\n<p> 如果一个对象没有强可达性，但是它可以通过一个软引用(soft reference.)来使用，那么它就具有软可达性。只有当系统需要更多内存时，GC才会回收具有软可达性的对象。在内存不足前，GC保证一定回收软可达的对象。</p>\n</blockquote>\n<p>就是说，软引用对象的回收去决定于不同版本JVM的回收机制，回收之后软引用会返回null。</p>\n<ul>\n<li>弱可达</li>\n</ul>\n<blockquote>\n<p>如果一个对象既没有强可达性，也没有软可达性，但是它可以通过一个弱引用(weak reference)来使用，那么他就具有弱可达性。当弱引用指向的弱可达对象没有其他的引用，那么这个对象就会被回收。</p>\n</blockquote>\n<ul>\n<li>虚可达<blockquote>\n<p>如果一个对象既没有强可达性，也没有软可达性、弱可达性，他已经被终结（finalized），并且有一些虚引用（phantom reference）指向它，那么它就具有虚可达性。</p>\n</blockquote>\n</li>\n</ul>\n<p>就是说虚引用指向的对象已经被终结了，永远返回null。</p>\n<ul>\n<li>不可达<blockquote>\n<p>当一个对象不能通过以上的方式指向，那么这个对象就变得不可达，并因此适合被回收。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"引用的类型\"><a href=\"#引用的类型\" class=\"headerlink\" title=\"引用的类型\"></a>引用的类型</h3><p>JDK1.2之后，对象引用被分为四个级别。</p>\n<ul>\n<li>强引用</li>\n</ul>\n<p>垃圾回收器不回收强引用，如若内存空间不足，jvm将会OOM错误。</p>\n<ul>\n<li>软引用</li>\n</ul>\n<p>够空间就不回收，不够就回。可用于实现内存敏感的高速缓存</p>\n<ul>\n<li>弱引用</li>\n</ul>\n<p>对象若是有弱引用，那将具有更短的生命周期，一旦它被扫描到，不管内存空间是否充足都会被回收，不过由于垃圾回收器是个级别很低的线程，所以不一定会很快发现弱引用对象。</p>\n<ul>\n<li>虚引用</li>\n</ul>\n<p>形同虚设，并不决定对象生命周期，主要用来跟踪对象被GC回收的活动。</p>\n"},{"title":"java CAS与一些锁知识的学习","date":"2016-04-18T02:20:11.000Z","_content":"\n\n## CAS\nCAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。\n\n>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。\n\nCAS是一个乐观的操作，如果CAS失败，线程不会立刻被挂起，而是再次尝试或者采取一些更合理的策略(比如什么都不做或者恢复)，这与使用锁的情况不同(获锁失败线程将被挂起)\n\nCAS的实现原理大致如下：\n\n``` java\nif (this == expect) {\n  this = update\n return true;\n} else {\nreturn false;\n}\n\n```\n\n这里请注意，代码中的if(this==expect) this=update,这两步操作一起是由硬件实现原子性的，这样就能够实现CAS操作的原子性。\n\n## 有关于的锁知识\n\n\n### cpu的锁知识\n1. 处理器自动保证基本内存操作的原子性\n2. 使用总线锁保证原子性，使用处理器提供的一个LOCK#信号，其他处理器的请求将被阻塞住，则原处理器可以独占共享内存。\n3. 使用缓存锁保证原子性。因为总线锁开销大，会把其他处理器通往其他内存的通信锁着，所以使用缓存锁，这样也可以保证缓存被独占访问。\n\n### 乐观锁和悲观锁\n>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。\n\n>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。\n\n## CAS缺点\n1. ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。\n2. 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。\n3. 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。","source":"_posts/20160418-01.md","raw":"---\ntitle: java CAS与一些锁知识的学习\ndate: 2016-04-18 10:20:11\ntags: java\ncategories: java\n\n---\n\n\n## CAS\nCAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。\n\n>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。\n\nCAS是一个乐观的操作，如果CAS失败，线程不会立刻被挂起，而是再次尝试或者采取一些更合理的策略(比如什么都不做或者恢复)，这与使用锁的情况不同(获锁失败线程将被挂起)\n\nCAS的实现原理大致如下：\n\n``` java\nif (this == expect) {\n  this = update\n return true;\n} else {\nreturn false;\n}\n\n```\n\n这里请注意，代码中的if(this==expect) this=update,这两步操作一起是由硬件实现原子性的，这样就能够实现CAS操作的原子性。\n\n## 有关于的锁知识\n\n\n### cpu的锁知识\n1. 处理器自动保证基本内存操作的原子性\n2. 使用总线锁保证原子性，使用处理器提供的一个LOCK#信号，其他处理器的请求将被阻塞住，则原处理器可以独占共享内存。\n3. 使用缓存锁保证原子性。因为总线锁开销大，会把其他处理器通往其他内存的通信锁着，所以使用缓存锁，这样也可以保证缓存被独占访问。\n\n### 乐观锁和悲观锁\n>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。\n\n>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。\n\n## CAS缺点\n1. ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。\n2. 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。\n3. 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。","slug":"20160418-01","published":1,"updated":"2016-04-18T02:46:10.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cindau1x2000y30xg1sgatfgi","content":"<h2 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h2><p>CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。</p>\n<blockquote>\n<p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>\n</blockquote>\n<p>CAS是一个乐观的操作，如果CAS失败，线程不会立刻被挂起，而是再次尝试或者采取一些更合理的策略(比如什么都不做或者恢复)，这与使用锁的情况不同(获锁失败线程将被挂起)</p>\n<p>CAS的实现原理大致如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == expect) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span> = update</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里请注意，代码中的if(this==expect) this=update,这两步操作一起是由硬件实现原子性的，这样就能够实现CAS操作的原子性。</p>\n<h2 id=\"有关于的锁知识\"><a href=\"#有关于的锁知识\" class=\"headerlink\" title=\"有关于的锁知识\"></a>有关于的锁知识</h2><h3 id=\"cpu的锁知识\"><a href=\"#cpu的锁知识\" class=\"headerlink\" title=\"cpu的锁知识\"></a>cpu的锁知识</h3><ol>\n<li>处理器自动保证基本内存操作的原子性</li>\n<li>使用总线锁保证原子性，使用处理器提供的一个LOCK#信号，其他处理器的请求将被阻塞住，则原处理器可以独占共享内存。</li>\n<li>使用缓存锁保证原子性。因为总线锁开销大，会把其他处理器通往其他内存的通信锁着，所以使用缓存锁，这样也可以保证缓存被独占访问。</li>\n</ol>\n<h3 id=\"乐观锁和悲观锁\"><a href=\"#乐观锁和悲观锁\" class=\"headerlink\" title=\"乐观锁和悲观锁\"></a>乐观锁和悲观锁</h3><blockquote>\n<p>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>\n<p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p>\n</blockquote>\n<h2 id=\"CAS缺点\"><a href=\"#CAS缺点\" class=\"headerlink\" title=\"CAS缺点\"></a>CAS缺点</h2><ol>\n<li>ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</li>\n<li>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</li>\n<li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h2><p>CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。</p>\n<blockquote>\n<p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>\n</blockquote>\n<p>CAS是一个乐观的操作，如果CAS失败，线程不会立刻被挂起，而是再次尝试或者采取一些更合理的策略(比如什么都不做或者恢复)，这与使用锁的情况不同(获锁失败线程将被挂起)</p>\n<p>CAS的实现原理大致如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == expect) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span> = update</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里请注意，代码中的if(this==expect) this=update,这两步操作一起是由硬件实现原子性的，这样就能够实现CAS操作的原子性。</p>\n<h2 id=\"有关于的锁知识\"><a href=\"#有关于的锁知识\" class=\"headerlink\" title=\"有关于的锁知识\"></a>有关于的锁知识</h2><h3 id=\"cpu的锁知识\"><a href=\"#cpu的锁知识\" class=\"headerlink\" title=\"cpu的锁知识\"></a>cpu的锁知识</h3><ol>\n<li>处理器自动保证基本内存操作的原子性</li>\n<li>使用总线锁保证原子性，使用处理器提供的一个LOCK#信号，其他处理器的请求将被阻塞住，则原处理器可以独占共享内存。</li>\n<li>使用缓存锁保证原子性。因为总线锁开销大，会把其他处理器通往其他内存的通信锁着，所以使用缓存锁，这样也可以保证缓存被独占访问。</li>\n</ol>\n<h3 id=\"乐观锁和悲观锁\"><a href=\"#乐观锁和悲观锁\" class=\"headerlink\" title=\"乐观锁和悲观锁\"></a>乐观锁和悲观锁</h3><blockquote>\n<p>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>\n<p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p>\n</blockquote>\n<h2 id=\"CAS缺点\"><a href=\"#CAS缺点\" class=\"headerlink\" title=\"CAS缺点\"></a>CAS缺点</h2><ol>\n<li>ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</li>\n<li>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</li>\n<li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</li>\n</ol>\n"},{"title":"设计模式之命令模式","date":"2016-04-17T08:18:10.000Z","_content":"\n## 命令模式\n\n{% asset_img command.jpg This is an example image %}\n\n>在软件系统中，“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合，比如要对行为进行“记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，实现二者之间的松耦合。这就是命令模式（Command Pattern）。\n\n由类图可知，命令模式抽象出Command类，专门封装命令，这个类里还会有特定的具体接受者用于执行具体的命令。Client创建Command类并传入具体的接受者，Invoker类（**比如遥控器**）负责执行Command对象。也就是说，Command类只把excucu方法暴露出来让Invoker类执行。\n\n同时撤销命令也可以实现，在Command类里实现undo方法，并且在Invoker中保存之前的Command类。\n\n>\n1. 命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。\n2. 每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。\n3. 命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。\n4. 命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。\n5. 命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。\n\n### 模式优点\n1. 降低对象之间的耦合度。\n2. 新的命令可以很容易地加入到系统中。\n3. 可以比较容易地设计一个组合命令。\n4. 调用同一方法实现不同的功能\n\n### 模式缺点\n使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。\n\n### 适用环境\n1. 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。\n2. 系统需要在不同的时间指定请求、将请求排队和执行请求。\n3. 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。\n4. 系统需要将一组操作组合在一起，即支持宏命令。","source":"_posts/20160417-01.md","raw":"---\ntitle: 设计模式之命令模式\ndate: 2016-04-17 16:18:10\ntags: 设计模式\ncategories: 设计模式\n\n---\n\n## 命令模式\n\n{% asset_img command.jpg This is an example image %}\n\n>在软件系统中，“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合，比如要对行为进行“记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，实现二者之间的松耦合。这就是命令模式（Command Pattern）。\n\n由类图可知，命令模式抽象出Command类，专门封装命令，这个类里还会有特定的具体接受者用于执行具体的命令。Client创建Command类并传入具体的接受者，Invoker类（**比如遥控器**）负责执行Command对象。也就是说，Command类只把excucu方法暴露出来让Invoker类执行。\n\n同时撤销命令也可以实现，在Command类里实现undo方法，并且在Invoker中保存之前的Command类。\n\n>\n1. 命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。\n2. 每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。\n3. 命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。\n4. 命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。\n5. 命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。\n\n### 模式优点\n1. 降低对象之间的耦合度。\n2. 新的命令可以很容易地加入到系统中。\n3. 可以比较容易地设计一个组合命令。\n4. 调用同一方法实现不同的功能\n\n### 模式缺点\n使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。\n\n### 适用环境\n1. 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。\n2. 系统需要在不同的时间指定请求、将请求排队和执行请求。\n3. 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。\n4. 系统需要将一组操作组合在一起，即支持宏命令。","slug":"20160417-01","published":1,"updated":"2016-04-17T08:51:08.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cindau1x4001130xgawppbios","content":"<h2 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h2><img src=\"/2016/04/17/20160417-01/command.jpg\" alt=\"This is an example image\" title=\"This is an example image\">\n<blockquote>\n<p>在软件系统中，“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合，比如要对行为进行“记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，实现二者之间的松耦合。这就是命令模式（Command Pattern）。</p>\n</blockquote>\n<p>由类图可知，命令模式抽象出Command类，专门封装命令，这个类里还会有特定的具体接受者用于执行具体的命令。Client创建Command类并传入具体的接受者，Invoker类（<strong>比如遥控器</strong>）负责执行Command对象。也就是说，Command类只把excucu方法暴露出来让Invoker类执行。</p>\n<p>同时撤销命令也可以实现，在Command类里实现undo方法，并且在Invoker中保存之前的Command类。</p>\n<p>&gt;</p>\n<ol>\n<li>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。</li>\n<li>每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。</li>\n<li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li>\n<li>命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li>\n<li>命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。</li>\n</ol>\n<h3 id=\"模式优点\"><a href=\"#模式优点\" class=\"headerlink\" title=\"模式优点\"></a>模式优点</h3><ol>\n<li>降低对象之间的耦合度。</li>\n<li>新的命令可以很容易地加入到系统中。</li>\n<li>可以比较容易地设计一个组合命令。</li>\n<li>调用同一方法实现不同的功能</li>\n</ol>\n<h3 id=\"模式缺点\"><a href=\"#模式缺点\" class=\"headerlink\" title=\"模式缺点\"></a>模式缺点</h3><p>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</p>\n<h3 id=\"适用环境\"><a href=\"#适用环境\" class=\"headerlink\" title=\"适用环境\"></a>适用环境</h3><ol>\n<li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li>\n<li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li>\n<li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li>\n<li>系统需要将一组操作组合在一起，即支持宏命令。</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h2><img src=\"/2016/04/17/20160417-01/command.jpg\" alt=\"This is an example image\" title=\"This is an example image\">\n<blockquote>\n<p>在软件系统中，“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合，比如要对行为进行“记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，实现二者之间的松耦合。这就是命令模式（Command Pattern）。</p>\n</blockquote>\n<p>由类图可知，命令模式抽象出Command类，专门封装命令，这个类里还会有特定的具体接受者用于执行具体的命令。Client创建Command类并传入具体的接受者，Invoker类（<strong>比如遥控器</strong>）负责执行Command对象。也就是说，Command类只把excucu方法暴露出来让Invoker类执行。</p>\n<p>同时撤销命令也可以实现，在Command类里实现undo方法，并且在Invoker中保存之前的Command类。</p>\n<p>&gt;</p>\n<ol>\n<li>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。</li>\n<li>每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。</li>\n<li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li>\n<li>命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li>\n<li>命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。</li>\n</ol>\n<h3 id=\"模式优点\"><a href=\"#模式优点\" class=\"headerlink\" title=\"模式优点\"></a>模式优点</h3><ol>\n<li>降低对象之间的耦合度。</li>\n<li>新的命令可以很容易地加入到系统中。</li>\n<li>可以比较容易地设计一个组合命令。</li>\n<li>调用同一方法实现不同的功能</li>\n</ol>\n<h3 id=\"模式缺点\"><a href=\"#模式缺点\" class=\"headerlink\" title=\"模式缺点\"></a>模式缺点</h3><p>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</p>\n<h3 id=\"适用环境\"><a href=\"#适用环境\" class=\"headerlink\" title=\"适用环境\"></a>适用环境</h3><ol>\n<li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li>\n<li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li>\n<li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li>\n<li>系统需要将一组操作组合在一起，即支持宏命令。</li>\n</ol>\n"},{"title":"有关操作系统I/O的一些原理","date":"2016-04-22T16:34:44.000Z","_content":"\n## I/O设备\nI/O设备大致分为两类\n\n### 块设备\n信息存储在固定大小的块中，每个块都有自己的地址，是可寻址的。如硬盘，USB盘，ROM\n\n### 字符设备\n字符设备以字符为单位发送或者接受一个字符流，不考虑任何块结构，是不可寻址的，也没有任何寻道操作。比如打印机，网络接口，鼠标。\n\n### 其他\n以上分类并不完美，比如时钟，工作是按照预定的时间间隔产生中断，海油内存映射的显示器也不符合以上模型。\n\n## 设备控制器\nI/O设备一般由机械部件和电子部件两部分组成，电子部分称作**设备控制器**或者**适配器**。\n\n{% asset_img io.png This is an example image %}\n\n控制器的任务是把串行的位流转换成字节块\n\n## 内存映射\n内存映射是指将硬盘上文件的位置与进程逻辑地址空间中一块大小相同的区域一一对应，当要访问内存中一段数据时，转换为访问文件的某一段数据。这种方式的目的同样是减少数据在用户空间和内核空间之间的拷贝操作。当大量数据需要传输的时候，采用内存映射方式去访问文件会获得比较好的效率。\n\n\n## 缓存\n对于IO设备，缓冲是一个重要问题。\n{% asset_img buffer.jpg This is an example image %}\n\n### 用户缓冲区\n一种改进措施是，在用户空间设置缓冲区提高效率。但是万一缓冲区被分页出去了则相当危险，这要锁定内存，但是锁定内存降低分页效率。\n\n### 内核缓冲区\n另一种改进是在内核空间创建一个缓冲区，该缓冲区满的时候，将用户缓存区调入内存并复制过去。\n\n### 双缓冲区\n只用一个内核缓冲区的话，当内核缓冲区满并且还没写入用户缓冲区的时候将无法写入数据。所以设置两个内核缓冲区做缓冲，一个满了的时候临时使用另外一个。\n\n### 循环缓冲区\n被广泛使用，一个内存区域设置两个指针，一个指向下一个空闲位置，一个指向数据位置。两个指针环绕，并且到达顶部时返回底部。\n\n","source":"_posts/20160423-01.md","raw":"---\ntitle: 有关操作系统I/O的一些原理\ndate: 2016-04-23 00:34:44\ntags: 操作系统\ncategories: 计算机原理\n\n---\n\n## I/O设备\nI/O设备大致分为两类\n\n### 块设备\n信息存储在固定大小的块中，每个块都有自己的地址，是可寻址的。如硬盘，USB盘，ROM\n\n### 字符设备\n字符设备以字符为单位发送或者接受一个字符流，不考虑任何块结构，是不可寻址的，也没有任何寻道操作。比如打印机，网络接口，鼠标。\n\n### 其他\n以上分类并不完美，比如时钟，工作是按照预定的时间间隔产生中断，海油内存映射的显示器也不符合以上模型。\n\n## 设备控制器\nI/O设备一般由机械部件和电子部件两部分组成，电子部分称作**设备控制器**或者**适配器**。\n\n{% asset_img io.png This is an example image %}\n\n控制器的任务是把串行的位流转换成字节块\n\n## 内存映射\n内存映射是指将硬盘上文件的位置与进程逻辑地址空间中一块大小相同的区域一一对应，当要访问内存中一段数据时，转换为访问文件的某一段数据。这种方式的目的同样是减少数据在用户空间和内核空间之间的拷贝操作。当大量数据需要传输的时候，采用内存映射方式去访问文件会获得比较好的效率。\n\n\n## 缓存\n对于IO设备，缓冲是一个重要问题。\n{% asset_img buffer.jpg This is an example image %}\n\n### 用户缓冲区\n一种改进措施是，在用户空间设置缓冲区提高效率。但是万一缓冲区被分页出去了则相当危险，这要锁定内存，但是锁定内存降低分页效率。\n\n### 内核缓冲区\n另一种改进是在内核空间创建一个缓冲区，该缓冲区满的时候，将用户缓存区调入内存并复制过去。\n\n### 双缓冲区\n只用一个内核缓冲区的话，当内核缓冲区满并且还没写入用户缓冲区的时候将无法写入数据。所以设置两个内核缓冲区做缓冲，一个满了的时候临时使用另外一个。\n\n### 循环缓冲区\n被广泛使用，一个内存区域设置两个指针，一个指向下一个空闲位置，一个指向数据位置。两个指针环绕，并且到达顶部时返回底部。\n\n","slug":"20160423-01","published":1,"updated":"2016-04-29T11:44:53.909Z","_id":"cindau1x9001630xgxjzkgorm","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"I-O设备\"><a href=\"#I-O设备\" class=\"headerlink\" title=\"I/O设备\"></a>I/O设备</h2><p>I/O设备大致分为两类</p>\n<h3 id=\"块设备\"><a href=\"#块设备\" class=\"headerlink\" title=\"块设备\"></a>块设备</h3><p>信息存储在固定大小的块中，每个块都有自己的地址，是可寻址的。如硬盘，USB盘，ROM</p>\n<h3 id=\"字符设备\"><a href=\"#字符设备\" class=\"headerlink\" title=\"字符设备\"></a>字符设备</h3><p>字符设备以字符为单位发送或者接受一个字符流，不考虑任何块结构，是不可寻址的，也没有任何寻道操作。比如打印机，网络接口，鼠标。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>以上分类并不完美，比如时钟，工作是按照预定的时间间隔产生中断，海油内存映射的显示器也不符合以上模型。</p>\n<h2 id=\"设备控制器\"><a href=\"#设备控制器\" class=\"headerlink\" title=\"设备控制器\"></a>设备控制器</h2><p>I/O设备一般由机械部件和电子部件两部分组成，电子部分称作<strong>设备控制器</strong>或者<strong>适配器</strong>。</p>\n<img src=\"/2016/04/23/20160423-01/io.png\" alt=\"This is an example image\" title=\"This is an example image\">\n<p>控制器的任务是把串行的位流转换成字节块</p>\n<h2 id=\"内存映射\"><a href=\"#内存映射\" class=\"headerlink\" title=\"内存映射\"></a>内存映射</h2><p>内存映射是指将硬盘上文件的位置与进程逻辑地址空间中一块大小相同的区域一一对应，当要访问内存中一段数据时，转换为访问文件的某一段数据。这种方式的目的同样是减少数据在用户空间和内核空间之间的拷贝操作。当大量数据需要传输的时候，采用内存映射方式去访问文件会获得比较好的效率。</p>\n<h2 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h2><p>对于IO设备，缓冲是一个重要问题。<br><img src=\"/2016/04/23/20160423-01/buffer.jpg\" alt=\"This is an example image\" title=\"This is an example image\"></p>\n<h3 id=\"用户缓冲区\"><a href=\"#用户缓冲区\" class=\"headerlink\" title=\"用户缓冲区\"></a>用户缓冲区</h3><p>一种改进措施是，在用户空间设置缓冲区提高效率。但是万一缓冲区被分页出去了则相当危险，这要锁定内存，但是锁定内存降低分页效率。</p>\n<h3 id=\"内核缓冲区\"><a href=\"#内核缓冲区\" class=\"headerlink\" title=\"内核缓冲区\"></a>内核缓冲区</h3><p>另一种改进是在内核空间创建一个缓冲区，该缓冲区满的时候，将用户缓存区调入内存并复制过去。</p>\n<h3 id=\"双缓冲区\"><a href=\"#双缓冲区\" class=\"headerlink\" title=\"双缓冲区\"></a>双缓冲区</h3><p>只用一个内核缓冲区的话，当内核缓冲区满并且还没写入用户缓冲区的时候将无法写入数据。所以设置两个内核缓冲区做缓冲，一个满了的时候临时使用另外一个。</p>\n<h3 id=\"循环缓冲区\"><a href=\"#循环缓冲区\" class=\"headerlink\" title=\"循环缓冲区\"></a>循环缓冲区</h3><p>被广泛使用，一个内存区域设置两个指针，一个指向下一个空闲位置，一个指向数据位置。两个指针环绕，并且到达顶部时返回底部。</p>\n","excerpt":"","more":"<h2 id=\"I-O设备\"><a href=\"#I-O设备\" class=\"headerlink\" title=\"I/O设备\"></a>I/O设备</h2><p>I/O设备大致分为两类</p>\n<h3 id=\"块设备\"><a href=\"#块设备\" class=\"headerlink\" title=\"块设备\"></a>块设备</h3><p>信息存储在固定大小的块中，每个块都有自己的地址，是可寻址的。如硬盘，USB盘，ROM</p>\n<h3 id=\"字符设备\"><a href=\"#字符设备\" class=\"headerlink\" title=\"字符设备\"></a>字符设备</h3><p>字符设备以字符为单位发送或者接受一个字符流，不考虑任何块结构，是不可寻址的，也没有任何寻道操作。比如打印机，网络接口，鼠标。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>以上分类并不完美，比如时钟，工作是按照预定的时间间隔产生中断，海油内存映射的显示器也不符合以上模型。</p>\n<h2 id=\"设备控制器\"><a href=\"#设备控制器\" class=\"headerlink\" title=\"设备控制器\"></a>设备控制器</h2><p>I/O设备一般由机械部件和电子部件两部分组成，电子部分称作<strong>设备控制器</strong>或者<strong>适配器</strong>。</p>\n<img src=\"/2016/04/23/20160423-01/io.png\" alt=\"This is an example image\" title=\"This is an example image\">\n<p>控制器的任务是把串行的位流转换成字节块</p>\n<h2 id=\"内存映射\"><a href=\"#内存映射\" class=\"headerlink\" title=\"内存映射\"></a>内存映射</h2><p>内存映射是指将硬盘上文件的位置与进程逻辑地址空间中一块大小相同的区域一一对应，当要访问内存中一段数据时，转换为访问文件的某一段数据。这种方式的目的同样是减少数据在用户空间和内核空间之间的拷贝操作。当大量数据需要传输的时候，采用内存映射方式去访问文件会获得比较好的效率。</p>\n<h2 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h2><p>对于IO设备，缓冲是一个重要问题。<br><img src=\"/2016/04/23/20160423-01/buffer.jpg\" alt=\"This is an example image\" title=\"This is an example image\"></p>\n<h3 id=\"用户缓冲区\"><a href=\"#用户缓冲区\" class=\"headerlink\" title=\"用户缓冲区\"></a>用户缓冲区</h3><p>一种改进措施是，在用户空间设置缓冲区提高效率。但是万一缓冲区被分页出去了则相当危险，这要锁定内存，但是锁定内存降低分页效率。</p>\n<h3 id=\"内核缓冲区\"><a href=\"#内核缓冲区\" class=\"headerlink\" title=\"内核缓冲区\"></a>内核缓冲区</h3><p>另一种改进是在内核空间创建一个缓冲区，该缓冲区满的时候，将用户缓存区调入内存并复制过去。</p>\n<h3 id=\"双缓冲区\"><a href=\"#双缓冲区\" class=\"headerlink\" title=\"双缓冲区\"></a>双缓冲区</h3><p>只用一个内核缓冲区的话，当内核缓冲区满并且还没写入用户缓冲区的时候将无法写入数据。所以设置两个内核缓冲区做缓冲，一个满了的时候临时使用另外一个。</p>\n<h3 id=\"循环缓冲区\"><a href=\"#循环缓冲区\" class=\"headerlink\" title=\"循环缓冲区\"></a>循环缓冲区</h3><p>被广泛使用，一个内存区域设置两个指针，一个指向下一个空闲位置，一个指向数据位置。两个指针环绕，并且到达顶部时返回底部。</p>\n"},{"title":"java中的内存泄露","date":"2016-04-16T13:05:19.000Z","_content":"\n## 内存泄露\n\n毫无疑问，java里也是存在内存泄露的。内存泄露，即为一个不再被程序使用的对象或变量还在内存中占据存储空间。\n\n判断一个内存空间是否符合垃圾回收标准：\n\n1. 给对象赋予空指针null，未再被使用\n2. 给对象赋予新值，重新分配了内存空间\n\n即便java中存在垃圾回收机制，也不能确保不再使用的对象被准确回收。\n\n主要可能有以下几个方面：\n\n1. 静态集合类，比如HashMap和Vector，生命周期与程序一致，则容器中的对象可能将不被释放，造成内存泄露。\n2. 各种数据库,网络，IO连接，需要显示close，否则很多类似ResultSet资源未能被很好的释放。\n3. 监听器，很多时候往往释放对象的时候没有释放对应的监听器。\n4. 变量不合理作用域，一个变量定义的作用大于其使用范围，导致被延后释放。解决方法可以是改为局部变量或者使用完成后设置为null\n5. 单例模式可能存在内存泄露，如果单例模式里面有一个无关对象的引用，将导致该对象不能被释放。\n","source":"_posts/20160416-01.md","raw":"---\ntitle: java中的内存泄露\ndate: 2016-04-16 21:05:19\ntags: java\ncategories: java\n\n---\n\n## 内存泄露\n\n毫无疑问，java里也是存在内存泄露的。内存泄露，即为一个不再被程序使用的对象或变量还在内存中占据存储空间。\n\n判断一个内存空间是否符合垃圾回收标准：\n\n1. 给对象赋予空指针null，未再被使用\n2. 给对象赋予新值，重新分配了内存空间\n\n即便java中存在垃圾回收机制，也不能确保不再使用的对象被准确回收。\n\n主要可能有以下几个方面：\n\n1. 静态集合类，比如HashMap和Vector，生命周期与程序一致，则容器中的对象可能将不被释放，造成内存泄露。\n2. 各种数据库,网络，IO连接，需要显示close，否则很多类似ResultSet资源未能被很好的释放。\n3. 监听器，很多时候往往释放对象的时候没有释放对应的监听器。\n4. 变量不合理作用域，一个变量定义的作用大于其使用范围，导致被延后释放。解决方法可以是改为局部变量或者使用完成后设置为null\n5. 单例模式可能存在内存泄露，如果单例模式里面有一个无关对象的引用，将导致该对象不能被释放。\n","slug":"20160416-01","published":1,"updated":"2016-04-16T13:16:15.689Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cindau1xb001930xgov31jf55","content":"<h2 id=\"内存泄露\"><a href=\"#内存泄露\" class=\"headerlink\" title=\"内存泄露\"></a>内存泄露</h2><p>毫无疑问，java里也是存在内存泄露的。内存泄露，即为一个不再被程序使用的对象或变量还在内存中占据存储空间。</p>\n<p>判断一个内存空间是否符合垃圾回收标准：</p>\n<ol>\n<li>给对象赋予空指针null，未再被使用</li>\n<li>给对象赋予新值，重新分配了内存空间</li>\n</ol>\n<p>即便java中存在垃圾回收机制，也不能确保不再使用的对象被准确回收。</p>\n<p>主要可能有以下几个方面：</p>\n<ol>\n<li>静态集合类，比如HashMap和Vector，生命周期与程序一致，则容器中的对象可能将不被释放，造成内存泄露。</li>\n<li>各种数据库,网络，IO连接，需要显示close，否则很多类似ResultSet资源未能被很好的释放。</li>\n<li>监听器，很多时候往往释放对象的时候没有释放对应的监听器。</li>\n<li>变量不合理作用域，一个变量定义的作用大于其使用范围，导致被延后释放。解决方法可以是改为局部变量或者使用完成后设置为null</li>\n<li>单例模式可能存在内存泄露，如果单例模式里面有一个无关对象的引用，将导致该对象不能被释放。</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"内存泄露\"><a href=\"#内存泄露\" class=\"headerlink\" title=\"内存泄露\"></a>内存泄露</h2><p>毫无疑问，java里也是存在内存泄露的。内存泄露，即为一个不再被程序使用的对象或变量还在内存中占据存储空间。</p>\n<p>判断一个内存空间是否符合垃圾回收标准：</p>\n<ol>\n<li>给对象赋予空指针null，未再被使用</li>\n<li>给对象赋予新值，重新分配了内存空间</li>\n</ol>\n<p>即便java中存在垃圾回收机制，也不能确保不再使用的对象被准确回收。</p>\n<p>主要可能有以下几个方面：</p>\n<ol>\n<li>静态集合类，比如HashMap和Vector，生命周期与程序一致，则容器中的对象可能将不被释放，造成内存泄露。</li>\n<li>各种数据库,网络，IO连接，需要显示close，否则很多类似ResultSet资源未能被很好的释放。</li>\n<li>监听器，很多时候往往释放对象的时候没有释放对应的监听器。</li>\n<li>变量不合理作用域，一个变量定义的作用大于其使用范围，导致被延后释放。解决方法可以是改为局部变量或者使用完成后设置为null</li>\n<li>单例模式可能存在内存泄露，如果单例模式里面有一个无关对象的引用，将导致该对象不能被释放。</li>\n</ol>\n"},{"title":"Android 消息机制","date":"2016-04-18T04:07:34.000Z","_content":"\n{% asset_img handler.jpg This is an example image %}\n\n如图可知Android的消息分法机制\n\n在Android中的每个线程都会绑定一个Looper。这个Looper是封装自ThreadLocal，即是线程的本地局部变量。Android的主线程（UI线程）启动时会自行绑定一个Looper，而这个Looper里面又会绑定一个消息队列，Looper将会循环读取这个消息队列里的消息进行执行。\n\nHandler创建时候要绑定一个消息队列，这个消息队列当然必须从Looper里取，而又因为Looper封装在ThreadLocal当中的，所以相当于Handler也和当前线程绑定了，因为必须取得当前线程的Looper，才能取得它的消息队列。Handler的任务就是两个，一是将消息post到消息队列里，二是从消息队列里取出来然后按照指定的方法去处理消息，根据上图就形成了一个循环。\n\n所以就不难理解，当我们新建一个线程的时候，为什么直接创建Handler会失败了，因为新建线程没有创建Looper，所以无法从新线程的ThreadLocal里取得。所以要Looper.prepare()以及Looper.loop(),来启动这个消息循环。\n","source":"_posts/20160418-02.md","raw":"---\ntitle: Android 消息机制\ndate: 2016-04-18 12:07:34\ntags: Android\ncategories: Android\n\n---\n\n{% asset_img handler.jpg This is an example image %}\n\n如图可知Android的消息分法机制\n\n在Android中的每个线程都会绑定一个Looper。这个Looper是封装自ThreadLocal，即是线程的本地局部变量。Android的主线程（UI线程）启动时会自行绑定一个Looper，而这个Looper里面又会绑定一个消息队列，Looper将会循环读取这个消息队列里的消息进行执行。\n\nHandler创建时候要绑定一个消息队列，这个消息队列当然必须从Looper里取，而又因为Looper封装在ThreadLocal当中的，所以相当于Handler也和当前线程绑定了，因为必须取得当前线程的Looper，才能取得它的消息队列。Handler的任务就是两个，一是将消息post到消息队列里，二是从消息队列里取出来然后按照指定的方法去处理消息，根据上图就形成了一个循环。\n\n所以就不难理解，当我们新建一个线程的时候，为什么直接创建Handler会失败了，因为新建线程没有创建Looper，所以无法从新线程的ThreadLocal里取得。所以要Looper.prepare()以及Looper.loop(),来启动这个消息循环。\n","slug":"20160418-02","published":1,"updated":"2016-04-18T04:18:54.835Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cindau1xg001e30xg8qrt4sw7","content":"<img src=\"/2016/04/18/20160418-02/handler.jpg\" alt=\"This is an example image\" title=\"This is an example image\">\n<p>如图可知Android的消息分法机制</p>\n<p>在Android中的每个线程都会绑定一个Looper。这个Looper是封装自ThreadLocal，即是线程的本地局部变量。Android的主线程（UI线程）启动时会自行绑定一个Looper，而这个Looper里面又会绑定一个消息队列，Looper将会循环读取这个消息队列里的消息进行执行。</p>\n<p>Handler创建时候要绑定一个消息队列，这个消息队列当然必须从Looper里取，而又因为Looper封装在ThreadLocal当中的，所以相当于Handler也和当前线程绑定了，因为必须取得当前线程的Looper，才能取得它的消息队列。Handler的任务就是两个，一是将消息post到消息队列里，二是从消息队列里取出来然后按照指定的方法去处理消息，根据上图就形成了一个循环。</p>\n<p>所以就不难理解，当我们新建一个线程的时候，为什么直接创建Handler会失败了，因为新建线程没有创建Looper，所以无法从新线程的ThreadLocal里取得。所以要Looper.prepare()以及Looper.loop(),来启动这个消息循环。</p>\n","excerpt":"","more":"<img src=\"/2016/04/18/20160418-02/handler.jpg\" alt=\"This is an example image\" title=\"This is an example image\">\n<p>如图可知Android的消息分法机制</p>\n<p>在Android中的每个线程都会绑定一个Looper。这个Looper是封装自ThreadLocal，即是线程的本地局部变量。Android的主线程（UI线程）启动时会自行绑定一个Looper，而这个Looper里面又会绑定一个消息队列，Looper将会循环读取这个消息队列里的消息进行执行。</p>\n<p>Handler创建时候要绑定一个消息队列，这个消息队列当然必须从Looper里取，而又因为Looper封装在ThreadLocal当中的，所以相当于Handler也和当前线程绑定了，因为必须取得当前线程的Looper，才能取得它的消息队列。Handler的任务就是两个，一是将消息post到消息队列里，二是从消息队列里取出来然后按照指定的方法去处理消息，根据上图就形成了一个循环。</p>\n<p>所以就不难理解，当我们新建一个线程的时候，为什么直接创建Handler会失败了，因为新建线程没有创建Looper，所以无法从新线程的ThreadLocal里取得。所以要Looper.prepare()以及Looper.loop(),来启动这个消息循环。</p>\n"},{"title":"java一些多进程知识点回顾","date":"2016-03-28T10:58:31.000Z","_content":"\n## 进程与线程\n\n进程有一个包含了程序内容和数据的地址空间，以及其它的资源，包括打开的文件、子进程和信号处理器等。不同进程的地址空间是互相隔离的。而线程表示的是程序的执行流程，是CPU调度的基本单位。线程有自己的程序计数器、寄存器、栈和帧等。引入线程的动机在于操作系统中阻塞式I/O的存在。当一个线程所执行的I/O被阻塞的时候，同一进程中的其它线程可以使用CPU来进行计算。这样的话，就提高了应用的执行效率。线程的概念在主流的操作系统和编程语言中都得到了支持。\n\n## 线程的生命周期\n\n一个线程存在不同的生命周期。如下图\n\n{% asset_img java-thread.jpg This is an example image %}\n\n\n - 新建状态\n>使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。\n\n - 就绪状态\n>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。\n\n - 运行状态\n>如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。\n\n - 阻塞状态\n>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。\n\n - 死亡状态\n>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。\n\n## java线程同步\n\n>在某个Java对象上面调用wait方法的时候，首先要检查当前线程是否获取到了这个对象上的锁。如果没有的话，就会直接抛出java.lang.IllegalMonitorStateException异常。如果有锁的话，就把当前线程添加到对象的等待集合中，并释放其所拥有的锁。当前线程被阻塞，无法继续执行，直到被从对象的等待集合中移除。引起某个线程从对象的等待集合中移除的原因有很多：对象上的notify方法被调用时，该线程被选中；对象上的notifyAll方法被调用；线程被中断；对于有超时限制的wait操作，当超过时间限制时；JVM内部实现在非正常情况下的操作。\n\n## volatile的用法\n\n>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其它线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其它内存操作一起重排序。Volatile变量不会被缓存在寄存器或者其它对处理器不可见的地方，因此在读取volatile类型的变量时，总会返回最新写入的值。\n\n其实也就是说，用volatile修饰的变量是不稳定的，经常要变动的，,编译器为了加快程序运行的速度,对一些变量的写操作会先在寄存器或者是CPU缓存上进行,最后才写入内存，volatile关键字保证不会被各种缓存机制优化，所以每次都可以直接去内存当中去读取出它的值。但是要注意，这就不能保证原子性了，只是提供了内存可见性。\n\n### 原子性\n>不管这个方法或者代码块被多少线程访问，方法和代码块中的语句只能作为一个整体执行，即当一个线程访问一个同步方法时，只有当方法执行完时，其他线程才能执行该方法。简单讲，就是一个线程一个线程来，而且必须全部执行完同步方法或代码块中的语句。\n\n### 内存可见性\n>这指的是一个线程在同步方法或者代码块中对共享变量做的任何改变，对随后的其他线程都是可见的\n\n因此可见，我们在对一个变量内存可见性高的时候应该使用这个关键字，经常需要读取出最新的值从内存中。并且需要注意的是，这个关键字**不能保证原子性（如++操作）**\n\n## 线程池的用法\n我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。\n\n## Executor 框架与线程池\n在 Java 5 之后，并发编程引入了一堆新的启动、调度和管理线程的API。Executor 框架便是 Java 5 中引入的，其内部使用了线程池机制，它在 java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，在 Java 5之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题——如果我们在构造器中启动一个线程，因为另一个任务可能会在构造器结束之前开始执行，此时可能会访问到初始化了一半的对象用 Executor 在构造器中。\n\nJava里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。\n\n","source":"_posts/20160328-01.md","raw":"---\ntitle: java一些多进程知识点回顾\ndate: 2016-03-28 18:58:31\ntags: java\ncategories: java\n\n---\n\n## 进程与线程\n\n进程有一个包含了程序内容和数据的地址空间，以及其它的资源，包括打开的文件、子进程和信号处理器等。不同进程的地址空间是互相隔离的。而线程表示的是程序的执行流程，是CPU调度的基本单位。线程有自己的程序计数器、寄存器、栈和帧等。引入线程的动机在于操作系统中阻塞式I/O的存在。当一个线程所执行的I/O被阻塞的时候，同一进程中的其它线程可以使用CPU来进行计算。这样的话，就提高了应用的执行效率。线程的概念在主流的操作系统和编程语言中都得到了支持。\n\n## 线程的生命周期\n\n一个线程存在不同的生命周期。如下图\n\n{% asset_img java-thread.jpg This is an example image %}\n\n\n - 新建状态\n>使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。\n\n - 就绪状态\n>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。\n\n - 运行状态\n>如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。\n\n - 阻塞状态\n>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。\n\n - 死亡状态\n>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。\n\n## java线程同步\n\n>在某个Java对象上面调用wait方法的时候，首先要检查当前线程是否获取到了这个对象上的锁。如果没有的话，就会直接抛出java.lang.IllegalMonitorStateException异常。如果有锁的话，就把当前线程添加到对象的等待集合中，并释放其所拥有的锁。当前线程被阻塞，无法继续执行，直到被从对象的等待集合中移除。引起某个线程从对象的等待集合中移除的原因有很多：对象上的notify方法被调用时，该线程被选中；对象上的notifyAll方法被调用；线程被中断；对于有超时限制的wait操作，当超过时间限制时；JVM内部实现在非正常情况下的操作。\n\n## volatile的用法\n\n>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其它线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其它内存操作一起重排序。Volatile变量不会被缓存在寄存器或者其它对处理器不可见的地方，因此在读取volatile类型的变量时，总会返回最新写入的值。\n\n其实也就是说，用volatile修饰的变量是不稳定的，经常要变动的，,编译器为了加快程序运行的速度,对一些变量的写操作会先在寄存器或者是CPU缓存上进行,最后才写入内存，volatile关键字保证不会被各种缓存机制优化，所以每次都可以直接去内存当中去读取出它的值。但是要注意，这就不能保证原子性了，只是提供了内存可见性。\n\n### 原子性\n>不管这个方法或者代码块被多少线程访问，方法和代码块中的语句只能作为一个整体执行，即当一个线程访问一个同步方法时，只有当方法执行完时，其他线程才能执行该方法。简单讲，就是一个线程一个线程来，而且必须全部执行完同步方法或代码块中的语句。\n\n### 内存可见性\n>这指的是一个线程在同步方法或者代码块中对共享变量做的任何改变，对随后的其他线程都是可见的\n\n因此可见，我们在对一个变量内存可见性高的时候应该使用这个关键字，经常需要读取出最新的值从内存中。并且需要注意的是，这个关键字**不能保证原子性（如++操作）**\n\n## 线程池的用法\n我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。\n\n## Executor 框架与线程池\n在 Java 5 之后，并发编程引入了一堆新的启动、调度和管理线程的API。Executor 框架便是 Java 5 中引入的，其内部使用了线程池机制，它在 java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，在 Java 5之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题——如果我们在构造器中启动一个线程，因为另一个任务可能会在构造器结束之前开始执行，此时可能会访问到初始化了一半的对象用 Executor 在构造器中。\n\nJava里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。\n\n","slug":"20160328-01","published":1,"updated":"2016-03-29T12:10:05.453Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cindau1xi001h30xg4eednt6a","content":"<h2 id=\"进程与线程\"><a href=\"#进程与线程\" class=\"headerlink\" title=\"进程与线程\"></a>进程与线程</h2><p>进程有一个包含了程序内容和数据的地址空间，以及其它的资源，包括打开的文件、子进程和信号处理器等。不同进程的地址空间是互相隔离的。而线程表示的是程序的执行流程，是CPU调度的基本单位。线程有自己的程序计数器、寄存器、栈和帧等。引入线程的动机在于操作系统中阻塞式I/O的存在。当一个线程所执行的I/O被阻塞的时候，同一进程中的其它线程可以使用CPU来进行计算。这样的话，就提高了应用的执行效率。线程的概念在主流的操作系统和编程语言中都得到了支持。</p>\n<h2 id=\"线程的生命周期\"><a href=\"#线程的生命周期\" class=\"headerlink\" title=\"线程的生命周期\"></a>线程的生命周期</h2><p>一个线程存在不同的生命周期。如下图</p>\n<img src=\"/2016/03/28/20160328-01/java-thread.jpg\" alt=\"This is an example image\" title=\"This is an example image\">\n<ul>\n<li><p>新建状态</p>\n<blockquote>\n<p>使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。</p>\n</blockquote>\n</li>\n<li><p>就绪状态</p>\n<blockquote>\n<p>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p>\n</blockquote>\n</li>\n<li><p>运行状态</p>\n<blockquote>\n<p>如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p>\n</blockquote>\n</li>\n<li><p>阻塞状态</p>\n<blockquote>\n<p>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。</p>\n</blockquote>\n</li>\n<li><p>死亡状态</p>\n<blockquote>\n<p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"java线程同步\"><a href=\"#java线程同步\" class=\"headerlink\" title=\"java线程同步\"></a>java线程同步</h2><blockquote>\n<p>在某个Java对象上面调用wait方法的时候，首先要检查当前线程是否获取到了这个对象上的锁。如果没有的话，就会直接抛出java.lang.IllegalMonitorStateException异常。如果有锁的话，就把当前线程添加到对象的等待集合中，并释放其所拥有的锁。当前线程被阻塞，无法继续执行，直到被从对象的等待集合中移除。引起某个线程从对象的等待集合中移除的原因有很多：对象上的notify方法被调用时，该线程被选中；对象上的notifyAll方法被调用；线程被中断；对于有超时限制的wait操作，当超过时间限制时；JVM内部实现在非正常情况下的操作。</p>\n</blockquote>\n<h2 id=\"volatile的用法\"><a href=\"#volatile的用法\" class=\"headerlink\" title=\"volatile的用法\"></a>volatile的用法</h2><blockquote>\n<p>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其它线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其它内存操作一起重排序。Volatile变量不会被缓存在寄存器或者其它对处理器不可见的地方，因此在读取volatile类型的变量时，总会返回最新写入的值。</p>\n</blockquote>\n<p>其实也就是说，用volatile修饰的变量是不稳定的，经常要变动的，,编译器为了加快程序运行的速度,对一些变量的写操作会先在寄存器或者是CPU缓存上进行,最后才写入内存，volatile关键字保证不会被各种缓存机制优化，所以每次都可以直接去内存当中去读取出它的值。但是要注意，这就不能保证原子性了，只是提供了内存可见性。</p>\n<h3 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h3><blockquote>\n<p>不管这个方法或者代码块被多少线程访问，方法和代码块中的语句只能作为一个整体执行，即当一个线程访问一个同步方法时，只有当方法执行完时，其他线程才能执行该方法。简单讲，就是一个线程一个线程来，而且必须全部执行完同步方法或代码块中的语句。</p>\n</blockquote>\n<h3 id=\"内存可见性\"><a href=\"#内存可见性\" class=\"headerlink\" title=\"内存可见性\"></a>内存可见性</h3><blockquote>\n<p>这指的是一个线程在同步方法或者代码块中对共享变量做的任何改变，对随后的其他线程都是可见的</p>\n</blockquote>\n<p>因此可见，我们在对一个变量内存可见性高的时候应该使用这个关键字，经常需要读取出最新的值从内存中。并且需要注意的是，这个关键字<strong>不能保证原子性（如++操作）</strong></p>\n<h2 id=\"线程池的用法\"><a href=\"#线程池的用法\" class=\"headerlink\" title=\"线程池的用法\"></a>线程池的用法</h2><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>\n<h2 id=\"Executor-框架与线程池\"><a href=\"#Executor-框架与线程池\" class=\"headerlink\" title=\"Executor 框架与线程池\"></a>Executor 框架与线程池</h2><p>在 Java 5 之后，并发编程引入了一堆新的启动、调度和管理线程的API。Executor 框架便是 Java 5 中引入的，其内部使用了线程池机制，它在 java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，在 Java 5之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题——如果我们在构造器中启动一个线程，因为另一个任务可能会在构造器结束之前开始执行，此时可能会访问到初始化了一半的对象用 Executor 在构造器中。</p>\n<p>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。</p>\n","excerpt":"","more":"<h2 id=\"进程与线程\"><a href=\"#进程与线程\" class=\"headerlink\" title=\"进程与线程\"></a>进程与线程</h2><p>进程有一个包含了程序内容和数据的地址空间，以及其它的资源，包括打开的文件、子进程和信号处理器等。不同进程的地址空间是互相隔离的。而线程表示的是程序的执行流程，是CPU调度的基本单位。线程有自己的程序计数器、寄存器、栈和帧等。引入线程的动机在于操作系统中阻塞式I/O的存在。当一个线程所执行的I/O被阻塞的时候，同一进程中的其它线程可以使用CPU来进行计算。这样的话，就提高了应用的执行效率。线程的概念在主流的操作系统和编程语言中都得到了支持。</p>\n<h2 id=\"线程的生命周期\"><a href=\"#线程的生命周期\" class=\"headerlink\" title=\"线程的生命周期\"></a>线程的生命周期</h2><p>一个线程存在不同的生命周期。如下图</p>\n<img src=\"/2016/03/28/20160328-01/java-thread.jpg\" alt=\"This is an example image\" title=\"This is an example image\">\n<ul>\n<li><p>新建状态</p>\n<blockquote>\n<p>使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。</p>\n</blockquote>\n</li>\n<li><p>就绪状态</p>\n<blockquote>\n<p>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p>\n</blockquote>\n</li>\n<li><p>运行状态</p>\n<blockquote>\n<p>如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p>\n</blockquote>\n</li>\n<li><p>阻塞状态</p>\n<blockquote>\n<p>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。</p>\n</blockquote>\n</li>\n<li><p>死亡状态</p>\n<blockquote>\n<p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"java线程同步\"><a href=\"#java线程同步\" class=\"headerlink\" title=\"java线程同步\"></a>java线程同步</h2><blockquote>\n<p>在某个Java对象上面调用wait方法的时候，首先要检查当前线程是否获取到了这个对象上的锁。如果没有的话，就会直接抛出java.lang.IllegalMonitorStateException异常。如果有锁的话，就把当前线程添加到对象的等待集合中，并释放其所拥有的锁。当前线程被阻塞，无法继续执行，直到被从对象的等待集合中移除。引起某个线程从对象的等待集合中移除的原因有很多：对象上的notify方法被调用时，该线程被选中；对象上的notifyAll方法被调用；线程被中断；对于有超时限制的wait操作，当超过时间限制时；JVM内部实现在非正常情况下的操作。</p>\n</blockquote>\n<h2 id=\"volatile的用法\"><a href=\"#volatile的用法\" class=\"headerlink\" title=\"volatile的用法\"></a>volatile的用法</h2><blockquote>\n<p>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其它线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其它内存操作一起重排序。Volatile变量不会被缓存在寄存器或者其它对处理器不可见的地方，因此在读取volatile类型的变量时，总会返回最新写入的值。</p>\n</blockquote>\n<p>其实也就是说，用volatile修饰的变量是不稳定的，经常要变动的，,编译器为了加快程序运行的速度,对一些变量的写操作会先在寄存器或者是CPU缓存上进行,最后才写入内存，volatile关键字保证不会被各种缓存机制优化，所以每次都可以直接去内存当中去读取出它的值。但是要注意，这就不能保证原子性了，只是提供了内存可见性。</p>\n<h3 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h3><blockquote>\n<p>不管这个方法或者代码块被多少线程访问，方法和代码块中的语句只能作为一个整体执行，即当一个线程访问一个同步方法时，只有当方法执行完时，其他线程才能执行该方法。简单讲，就是一个线程一个线程来，而且必须全部执行完同步方法或代码块中的语句。</p>\n</blockquote>\n<h3 id=\"内存可见性\"><a href=\"#内存可见性\" class=\"headerlink\" title=\"内存可见性\"></a>内存可见性</h3><blockquote>\n<p>这指的是一个线程在同步方法或者代码块中对共享变量做的任何改变，对随后的其他线程都是可见的</p>\n</blockquote>\n<p>因此可见，我们在对一个变量内存可见性高的时候应该使用这个关键字，经常需要读取出最新的值从内存中。并且需要注意的是，这个关键字<strong>不能保证原子性（如++操作）</strong></p>\n<h2 id=\"线程池的用法\"><a href=\"#线程池的用法\" class=\"headerlink\" title=\"线程池的用法\"></a>线程池的用法</h2><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>\n<h2 id=\"Executor-框架与线程池\"><a href=\"#Executor-框架与线程池\" class=\"headerlink\" title=\"Executor 框架与线程池\"></a>Executor 框架与线程池</h2><p>在 Java 5 之后，并发编程引入了一堆新的启动、调度和管理线程的API。Executor 框架便是 Java 5 中引入的，其内部使用了线程池机制，它在 java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，在 Java 5之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题——如果我们在构造器中启动一个线程，因为另一个任务可能会在构造器结束之前开始执行，此时可能会访问到初始化了一半的对象用 Executor 在构造器中。</p>\n<p>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。</p>\n"},{"title":"java虚拟机笔记(3) 类加载机制","date":"2016-04-14T16:34:27.000Z","_content":"\n## 概述\n\njava虚拟机程序可以实现“一次编写，到处运行”。不同平台的虚拟机可以载入和执行一种平台无关的字节码。虚拟机定义规范时分成了java语言规范和虚拟机规范。jvm不和任何包括java文件在内的任何语言绑定，它只是解释执行class文件这种特定的二进制字节流。虚拟机有定义读取和解释class文件的规范，不仅仅java其他语言类似Groovy，JRuby，Jython都可以被解释成class字节码\n\n## 类加载时机\n\n类从被加载到虚拟机内存，到卸载出去为止，整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载。其中验证，准备，解析3个部分统称为连接。如图\n\n{% asset_img class_life.jpg This is an example image %}\n\n## 类的初始化时机\n\n严格规定，有且有且仅有五种情况立即开始**初始化**，自然前三个步骤要在更早进行，但虚拟机没有明确规范。\n\n1. 遇到new，getstatic，putstatic，invokestatic四条指令时，如果类没有进行过初始化则先触发使其初始化。\n2. 反射调用的时候，未初始化要初始化\n3. 初始化一个类时，先触发其父类的初始化\n4. main方法的类率先初始化\n5. jdk1.7动态语言支持，如果一个java.lang.invoke.MethodHandle实例最后解析的结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄\n\n其他情况，引用类都不会进行初始化，称为被动引用。\n比如，类加载时会先把一些类常量进行类传播优化存储到常量池中，所以调用每个类的静态常量未必会加载那个类。\n\n## 虚拟机加载过程\n\n### 加载\n加载阶段，虚拟机完成三件事\n1. 通过类全名来获得类的二进制流\n2. 讲这个字节流代表的静态存储结构转化为方法区的运行时数据结构\n3. 在内存中生成一个java.lang.Class对象，作为方法区这个类的各种数据访问入口\n\n加载和验证顺序可能是交叉运行\n\n### 验证\n连接阶段第一步，确保字节流包含的信息符合虚拟机要求，不会危害虚拟机自身安全。\n\n### 准备\n\n这个阶段正式为类变量分配内存和设置初始值。这些变量所使用的内存都在方法区分配。注意，这个阶段进行的内存分配仅仅包括类变量（static修饰的变量），而不是实例变量，实例变量在对象实例化时随着堆一起分配在java堆中。而初始化只是初始化数据类型的0值，而不是定义的值。\n\n### 解析\n\n解析过程将虚拟机常量池内的符号引用替换为直接引用。\n\n符号引用是一组符号描述引用的目标的，与虚拟机内存布局无关，引用目标也不一定已加载到内存中。直接引用是直接指向目标的指针，相对偏移量，或者句柄，与内存布局直接相关。有了这个，引用目标必定已经存在。\n\n### 初始化\n类加载过程的最后一步，到了初始化阶段才真正执行java程序代码。在准备阶段已经赋过系统初始值，而这个阶段将会根据程序员制定的主观计划去初始化变量。\n\n初始化阶段是执行类构造器<clinit>方法的过程。<clinit>方法是由编译器自动收集类中的所有类变量赋值动作和静态语句块(static块)合并产生的，**顺序是由语句在源文件中的出现顺序所决定的**。且父类的<clinit>方法必定先于子类\n\n## 类加载器\n对于任何一个类，都由加载它的类加载器，和这个类本身两者一起确定它在虚拟机中的唯一性。否则，就算两个类来自同一个class文件，类加载器不同，两个类也不相等。(instanceof的值为false)\n\n### 双亲委派模型\n\n从虚拟机角度讲只有两种不同的类加载器，启动类加载器和其他类加载器。前者是虚拟机内部，后者是外部独立的。后者都继承自抽象类java.lang.ClassLoader\n\n从Java程序员角度来看，则会使用到三种类加载器。\n1. 启动类加载器，这个类负责将存放在<JAVA_HOME>\\lib目录中的并且被虚拟机识别的类库加载到虚拟机内存中。\n2. 扩展类加载器，负责加载<JAVA_HOME>\\lib\\ext目录里的类，开发者可以直接使用扩展类加载器。\n3. 应用程序类加载器，由于是由ClassLoader中的getSystemClassLoader()方法的返回值，所以也称为系统加载器，负责加载用户路径指定的类库，开发者可以直接使用，如果程序中没有自定义类加载器，一般情况下这就是程序中默认的类加载器。\n\n如图就是双亲委派模型\n\n{% asset_img class_life.jpg This is an example image %}\n\n类加载器之间不会用继承的关系来实现，都是以组合的方式。\n\n如果一个类加载器收到了类加载请求，他首先不会自己尝试加载这个类，而是把这个请求委派个父类加载器去完成，每一个层次类加载器都是如此。因此所有的加载请求最终都应该传送到底层的启动类加载器里，只有父类无法完成这个请求时，子加载器才会尝试自己去加载\n\n这种优先级层次关系很好的避免了一些，加载出的类不同的情况\n","source":"_posts/20160415-01.md","raw":"---\ntitle: java虚拟机笔记(3) 类加载机制 \ndate: 2016-04-15 00:34:27\ntags: \n - java\n - java虚拟机\ncategories: java\n\n---\n\n## 概述\n\njava虚拟机程序可以实现“一次编写，到处运行”。不同平台的虚拟机可以载入和执行一种平台无关的字节码。虚拟机定义规范时分成了java语言规范和虚拟机规范。jvm不和任何包括java文件在内的任何语言绑定，它只是解释执行class文件这种特定的二进制字节流。虚拟机有定义读取和解释class文件的规范，不仅仅java其他语言类似Groovy，JRuby，Jython都可以被解释成class字节码\n\n## 类加载时机\n\n类从被加载到虚拟机内存，到卸载出去为止，整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载。其中验证，准备，解析3个部分统称为连接。如图\n\n{% asset_img class_life.jpg This is an example image %}\n\n## 类的初始化时机\n\n严格规定，有且有且仅有五种情况立即开始**初始化**，自然前三个步骤要在更早进行，但虚拟机没有明确规范。\n\n1. 遇到new，getstatic，putstatic，invokestatic四条指令时，如果类没有进行过初始化则先触发使其初始化。\n2. 反射调用的时候，未初始化要初始化\n3. 初始化一个类时，先触发其父类的初始化\n4. main方法的类率先初始化\n5. jdk1.7动态语言支持，如果一个java.lang.invoke.MethodHandle实例最后解析的结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄\n\n其他情况，引用类都不会进行初始化，称为被动引用。\n比如，类加载时会先把一些类常量进行类传播优化存储到常量池中，所以调用每个类的静态常量未必会加载那个类。\n\n## 虚拟机加载过程\n\n### 加载\n加载阶段，虚拟机完成三件事\n1. 通过类全名来获得类的二进制流\n2. 讲这个字节流代表的静态存储结构转化为方法区的运行时数据结构\n3. 在内存中生成一个java.lang.Class对象，作为方法区这个类的各种数据访问入口\n\n加载和验证顺序可能是交叉运行\n\n### 验证\n连接阶段第一步，确保字节流包含的信息符合虚拟机要求，不会危害虚拟机自身安全。\n\n### 准备\n\n这个阶段正式为类变量分配内存和设置初始值。这些变量所使用的内存都在方法区分配。注意，这个阶段进行的内存分配仅仅包括类变量（static修饰的变量），而不是实例变量，实例变量在对象实例化时随着堆一起分配在java堆中。而初始化只是初始化数据类型的0值，而不是定义的值。\n\n### 解析\n\n解析过程将虚拟机常量池内的符号引用替换为直接引用。\n\n符号引用是一组符号描述引用的目标的，与虚拟机内存布局无关，引用目标也不一定已加载到内存中。直接引用是直接指向目标的指针，相对偏移量，或者句柄，与内存布局直接相关。有了这个，引用目标必定已经存在。\n\n### 初始化\n类加载过程的最后一步，到了初始化阶段才真正执行java程序代码。在准备阶段已经赋过系统初始值，而这个阶段将会根据程序员制定的主观计划去初始化变量。\n\n初始化阶段是执行类构造器<clinit>方法的过程。<clinit>方法是由编译器自动收集类中的所有类变量赋值动作和静态语句块(static块)合并产生的，**顺序是由语句在源文件中的出现顺序所决定的**。且父类的<clinit>方法必定先于子类\n\n## 类加载器\n对于任何一个类，都由加载它的类加载器，和这个类本身两者一起确定它在虚拟机中的唯一性。否则，就算两个类来自同一个class文件，类加载器不同，两个类也不相等。(instanceof的值为false)\n\n### 双亲委派模型\n\n从虚拟机角度讲只有两种不同的类加载器，启动类加载器和其他类加载器。前者是虚拟机内部，后者是外部独立的。后者都继承自抽象类java.lang.ClassLoader\n\n从Java程序员角度来看，则会使用到三种类加载器。\n1. 启动类加载器，这个类负责将存放在<JAVA_HOME>\\lib目录中的并且被虚拟机识别的类库加载到虚拟机内存中。\n2. 扩展类加载器，负责加载<JAVA_HOME>\\lib\\ext目录里的类，开发者可以直接使用扩展类加载器。\n3. 应用程序类加载器，由于是由ClassLoader中的getSystemClassLoader()方法的返回值，所以也称为系统加载器，负责加载用户路径指定的类库，开发者可以直接使用，如果程序中没有自定义类加载器，一般情况下这就是程序中默认的类加载器。\n\n如图就是双亲委派模型\n\n{% asset_img class_life.jpg This is an example image %}\n\n类加载器之间不会用继承的关系来实现，都是以组合的方式。\n\n如果一个类加载器收到了类加载请求，他首先不会自己尝试加载这个类，而是把这个请求委派个父类加载器去完成，每一个层次类加载器都是如此。因此所有的加载请求最终都应该传送到底层的启动类加载器里，只有父类无法完成这个请求时，子加载器才会尝试自己去加载\n\n这种优先级层次关系很好的避免了一些，加载出的类不同的情况\n","slug":"20160415-01","published":1,"updated":"2016-04-15T17:14:50.647Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cindau1xn001m30xgpa9ulrjg","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>java虚拟机程序可以实现“一次编写，到处运行”。不同平台的虚拟机可以载入和执行一种平台无关的字节码。虚拟机定义规范时分成了java语言规范和虚拟机规范。jvm不和任何包括java文件在内的任何语言绑定，它只是解释执行class文件这种特定的二进制字节流。虚拟机有定义读取和解释class文件的规范，不仅仅java其他语言类似Groovy，JRuby，Jython都可以被解释成class字节码</p>\n<h2 id=\"类加载时机\"><a href=\"#类加载时机\" class=\"headerlink\" title=\"类加载时机\"></a>类加载时机</h2><p>类从被加载到虚拟机内存，到卸载出去为止，整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载。其中验证，准备，解析3个部分统称为连接。如图</p>\n<img src=\"/2016/04/15/20160415-01/class_life.jpg\" alt=\"This is an example image\" title=\"This is an example image\">\n<h2 id=\"类的初始化时机\"><a href=\"#类的初始化时机\" class=\"headerlink\" title=\"类的初始化时机\"></a>类的初始化时机</h2><p>严格规定，有且有且仅有五种情况立即开始<strong>初始化</strong>，自然前三个步骤要在更早进行，但虚拟机没有明确规范。</p>\n<ol>\n<li>遇到new，getstatic，putstatic，invokestatic四条指令时，如果类没有进行过初始化则先触发使其初始化。</li>\n<li>反射调用的时候，未初始化要初始化</li>\n<li>初始化一个类时，先触发其父类的初始化</li>\n<li>main方法的类率先初始化</li>\n<li>jdk1.7动态语言支持，如果一个java.lang.invoke.MethodHandle实例最后解析的结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄</li>\n</ol>\n<p>其他情况，引用类都不会进行初始化，称为被动引用。<br>比如，类加载时会先把一些类常量进行类传播优化存储到常量池中，所以调用每个类的静态常量未必会加载那个类。</p>\n<h2 id=\"虚拟机加载过程\"><a href=\"#虚拟机加载过程\" class=\"headerlink\" title=\"虚拟机加载过程\"></a>虚拟机加载过程</h2><h3 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h3><p>加载阶段，虚拟机完成三件事</p>\n<ol>\n<li>通过类全名来获得类的二进制流</li>\n<li>讲这个字节流代表的静态存储结构转化为方法区的运行时数据结构</li>\n<li>在内存中生成一个java.lang.Class对象，作为方法区这个类的各种数据访问入口</li>\n</ol>\n<p>加载和验证顺序可能是交叉运行</p>\n<h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><p>连接阶段第一步，确保字节流包含的信息符合虚拟机要求，不会危害虚拟机自身安全。</p>\n<h3 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h3><p>这个阶段正式为类变量分配内存和设置初始值。这些变量所使用的内存都在方法区分配。注意，这个阶段进行的内存分配仅仅包括类变量（static修饰的变量），而不是实例变量，实例变量在对象实例化时随着堆一起分配在java堆中。而初始化只是初始化数据类型的0值，而不是定义的值。</p>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>解析过程将虚拟机常量池内的符号引用替换为直接引用。</p>\n<p>符号引用是一组符号描述引用的目标的，与虚拟机内存布局无关，引用目标也不一定已加载到内存中。直接引用是直接指向目标的指针，相对偏移量，或者句柄，与内存布局直接相关。有了这个，引用目标必定已经存在。</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>类加载过程的最后一步，到了初始化阶段才真正执行java程序代码。在准备阶段已经赋过系统初始值，而这个阶段将会根据程序员制定的主观计划去初始化变量。</p>\n<p>初始化阶段是执行类构造器<clinit>方法的过程。<clinit>方法是由编译器自动收集类中的所有类变量赋值动作和静态语句块(static块)合并产生的，<strong>顺序是由语句在源文件中的出现顺序所决定的</strong>。且父类的<clinit>方法必定先于子类</clinit></clinit></clinit></p>\n<h2 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h2><p>对于任何一个类，都由加载它的类加载器，和这个类本身两者一起确定它在虚拟机中的唯一性。否则，就算两个类来自同一个class文件，类加载器不同，两个类也不相等。(instanceof的值为false)</p>\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><p>从虚拟机角度讲只有两种不同的类加载器，启动类加载器和其他类加载器。前者是虚拟机内部，后者是外部独立的。后者都继承自抽象类java.lang.ClassLoader</p>\n<p>从Java程序员角度来看，则会使用到三种类加载器。</p>\n<ol>\n<li>启动类加载器，这个类负责将存放在<java_home>\\lib目录中的并且被虚拟机识别的类库加载到虚拟机内存中。</java_home></li>\n<li>扩展类加载器，负责加载<java_home>\\lib\\ext目录里的类，开发者可以直接使用扩展类加载器。</java_home></li>\n<li>应用程序类加载器，由于是由ClassLoader中的getSystemClassLoader()方法的返回值，所以也称为系统加载器，负责加载用户路径指定的类库，开发者可以直接使用，如果程序中没有自定义类加载器，一般情况下这就是程序中默认的类加载器。</li>\n</ol>\n<p>如图就是双亲委派模型</p>\n<img src=\"/2016/04/15/20160415-01/class_life.jpg\" alt=\"This is an example image\" title=\"This is an example image\">\n<p>类加载器之间不会用继承的关系来实现，都是以组合的方式。</p>\n<p>如果一个类加载器收到了类加载请求，他首先不会自己尝试加载这个类，而是把这个请求委派个父类加载器去完成，每一个层次类加载器都是如此。因此所有的加载请求最终都应该传送到底层的启动类加载器里，只有父类无法完成这个请求时，子加载器才会尝试自己去加载</p>\n<p>这种优先级层次关系很好的避免了一些，加载出的类不同的情况</p>\n","excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>java虚拟机程序可以实现“一次编写，到处运行”。不同平台的虚拟机可以载入和执行一种平台无关的字节码。虚拟机定义规范时分成了java语言规范和虚拟机规范。jvm不和任何包括java文件在内的任何语言绑定，它只是解释执行class文件这种特定的二进制字节流。虚拟机有定义读取和解释class文件的规范，不仅仅java其他语言类似Groovy，JRuby，Jython都可以被解释成class字节码</p>\n<h2 id=\"类加载时机\"><a href=\"#类加载时机\" class=\"headerlink\" title=\"类加载时机\"></a>类加载时机</h2><p>类从被加载到虚拟机内存，到卸载出去为止，整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载。其中验证，准备，解析3个部分统称为连接。如图</p>\n<img src=\"/2016/04/15/20160415-01/class_life.jpg\" alt=\"This is an example image\" title=\"This is an example image\">\n<h2 id=\"类的初始化时机\"><a href=\"#类的初始化时机\" class=\"headerlink\" title=\"类的初始化时机\"></a>类的初始化时机</h2><p>严格规定，有且有且仅有五种情况立即开始<strong>初始化</strong>，自然前三个步骤要在更早进行，但虚拟机没有明确规范。</p>\n<ol>\n<li>遇到new，getstatic，putstatic，invokestatic四条指令时，如果类没有进行过初始化则先触发使其初始化。</li>\n<li>反射调用的时候，未初始化要初始化</li>\n<li>初始化一个类时，先触发其父类的初始化</li>\n<li>main方法的类率先初始化</li>\n<li>jdk1.7动态语言支持，如果一个java.lang.invoke.MethodHandle实例最后解析的结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄</li>\n</ol>\n<p>其他情况，引用类都不会进行初始化，称为被动引用。<br>比如，类加载时会先把一些类常量进行类传播优化存储到常量池中，所以调用每个类的静态常量未必会加载那个类。</p>\n<h2 id=\"虚拟机加载过程\"><a href=\"#虚拟机加载过程\" class=\"headerlink\" title=\"虚拟机加载过程\"></a>虚拟机加载过程</h2><h3 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h3><p>加载阶段，虚拟机完成三件事</p>\n<ol>\n<li>通过类全名来获得类的二进制流</li>\n<li>讲这个字节流代表的静态存储结构转化为方法区的运行时数据结构</li>\n<li>在内存中生成一个java.lang.Class对象，作为方法区这个类的各种数据访问入口</li>\n</ol>\n<p>加载和验证顺序可能是交叉运行</p>\n<h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><p>连接阶段第一步，确保字节流包含的信息符合虚拟机要求，不会危害虚拟机自身安全。</p>\n<h3 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h3><p>这个阶段正式为类变量分配内存和设置初始值。这些变量所使用的内存都在方法区分配。注意，这个阶段进行的内存分配仅仅包括类变量（static修饰的变量），而不是实例变量，实例变量在对象实例化时随着堆一起分配在java堆中。而初始化只是初始化数据类型的0值，而不是定义的值。</p>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>解析过程将虚拟机常量池内的符号引用替换为直接引用。</p>\n<p>符号引用是一组符号描述引用的目标的，与虚拟机内存布局无关，引用目标也不一定已加载到内存中。直接引用是直接指向目标的指针，相对偏移量，或者句柄，与内存布局直接相关。有了这个，引用目标必定已经存在。</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>类加载过程的最后一步，到了初始化阶段才真正执行java程序代码。在准备阶段已经赋过系统初始值，而这个阶段将会根据程序员制定的主观计划去初始化变量。</p>\n<p>初始化阶段是执行类构造器<clinit>方法的过程。<clinit>方法是由编译器自动收集类中的所有类变量赋值动作和静态语句块(static块)合并产生的，<strong>顺序是由语句在源文件中的出现顺序所决定的</strong>。且父类的<clinit>方法必定先于子类</p>\n<h2 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h2><p>对于任何一个类，都由加载它的类加载器，和这个类本身两者一起确定它在虚拟机中的唯一性。否则，就算两个类来自同一个class文件，类加载器不同，两个类也不相等。(instanceof的值为false)</p>\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><p>从虚拟机角度讲只有两种不同的类加载器，启动类加载器和其他类加载器。前者是虚拟机内部，后者是外部独立的。后者都继承自抽象类java.lang.ClassLoader</p>\n<p>从Java程序员角度来看，则会使用到三种类加载器。</p>\n<ol>\n<li>启动类加载器，这个类负责将存放在<JAVA_HOME>\\lib目录中的并且被虚拟机识别的类库加载到虚拟机内存中。</li>\n<li>扩展类加载器，负责加载<JAVA_HOME>\\lib\\ext目录里的类，开发者可以直接使用扩展类加载器。</li>\n<li>应用程序类加载器，由于是由ClassLoader中的getSystemClassLoader()方法的返回值，所以也称为系统加载器，负责加载用户路径指定的类库，开发者可以直接使用，如果程序中没有自定义类加载器，一般情况下这就是程序中默认的类加载器。</li>\n</ol>\n<p>如图就是双亲委派模型</p>\n<img src=\"/2016/04/15/20160415-01/class_life.jpg\" alt=\"This is an example image\" title=\"This is an example image\">\n<p>类加载器之间不会用继承的关系来实现，都是以组合的方式。</p>\n<p>如果一个类加载器收到了类加载请求，他首先不会自己尝试加载这个类，而是把这个请求委派个父类加载器去完成，每一个层次类加载器都是如此。因此所有的加载请求最终都应该传送到底层的启动类加载器里，只有父类无法完成这个请求时，子加载器才会尝试自己去加载</p>\n<p>这种优先级层次关系很好的避免了一些，加载出的类不同的情况</p>\n"},{"title":"安卓实战学习记录01","date":"2016-03-20T15:28:52.000Z","_content":"\n---\n\n## 顶部导航和左右滑动抽屉\n\n#### Toolbar\n\n跟导航栏有关则有**Actionbar**和**Toolbar** 查阅资料可知，Toolbar是在API21后引进的，放在v7库当中，是应用的内容标准工具栏，而**Actionbar**一些方法已经标注过时了。相比于**Actionbar**，它变得更加自由。\n\n使用Toolbar要先把主题样式里的Actionbar去掉，在manifest中\n\n    android:theme=\"@style/Theme.AppCompat.Light.NoActionBar\">\n\n\n此外toolbar 是没有tab的，他需要结合support库里的tablayout来完成原来actionbar里的tab功能。除此之外，你在使用toolbar的时候要先屏蔽掉\n\n定义好xml文件后，我们在java文件中引入toolbar这个类\n\n``` java\nprivate android.support.v7.widget.Toolbar toolbar;\n```\n\n这里注意要引用supportv7的包，否则会出错，Toolbar向下兼容，这样才可以接着调用**setSupportActionBar**\n\n\n``` java\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    oolbar = (android.support.v7.widget.Toolbar) findViewById(R.id.mytoolbar);\n    setSupportActionBar(toolbar);\n    }\n\n```\n\ntoolbar很灵活，因为它就是一个viewgroup。如果要显示navigationicon，也许最好的做法是把它在代码中进行set，因为xml中的设置可能要API21以上才能看见\n\n\n#### DrawerLayout\n官方在13年发布的一个布局，用以创建侧滑菜单。从此我们可以不需要使用github上的侧滑菜单项目了。要创建一个DrawerLayout，我们必须要把它定为根视图，这样再把主要视图作为第一个子节点放入\n\n\n#### CoordinatorLayout\n\n根据谷歌的官方文档\n>CoordinatorLayout is a super-powered FrameLayout.\n\n可以看到它真是super-powered\nCoordinatorLayout一般用于顶层布局和协调子布局。\n要使用它必须在Gradle把包引进来。\n\n``` java\ncompile 'com.android.support:design:23.1.1' \n```\n由于CoordinatorLayout基于FrameLayout，所以这里也提一下FrameLayout，并且再提一下待会用到的几个layout\n##### FrameLayout\n\n帧布局FrameLayout在Android的五大布局中是最简单的布局方式，在需要布局中的控件有重叠的情况下才使用。FrameLayout中的控件layout\\_margin设置要依赖layout\\_gravity属性，否则layout_margin设置无效。如果想要控件正常显示，可以将控件的layout\\_gravity设置为top,以屏幕左上角为参考点。\n\n\n##### AppBarLayout\n>AppBarLayout is a vertical LinearLayout which implements many of the features of material designs app bar concept, namely scrolling gestures.\n\n经常用来实现一线滑动效果并且经常和CoordinatorLayout配套使用\n\n##### TabLayout\n这也是谷歌推出的新控件，可以很方便的用来作标签导航。结合ViewPager一起使用能有很好的效果。\n\n### 标签页的具体实现\n\n标签页的主角毫无疑问就是TabLayout了。我们现在xml文件中定义TabLayout。\n\n\n``` java\n<android.support.design.widget.TabLayout\n   android:id=\"@+id/tabs\"\n   android:layout_width=\"match_parent\"\n   ndroid:layout_height=\"wrap_content\">\n\n```\n\n定义了之后就已经可以标签名之类的属性了。但是我们的目的是标签分页实现之后跳转到不同的Fragment。所以我们还得使用一个ViewPager跟TabLayout配套使用。要使得标签跳转，可以直接用**FragmentPagerAdapter** 跟TabLayout配套使用。这样这个Adapter就同时控制了TabLayout和ViewPager并使他们数据同步。\n``` java\n        <android.support.v4.view.ViewPager\n            android:id=\"@+id/myviewpager\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\">\n\n        </android.support.v4.view.ViewPager>\n```\n\n接下来是代码部分了\n``` java\n        TabLayout mTabLayout = (TabLayout) findViewById(R.id.tabs);\n\n        //取得一个自定义PagerAdapter的实例\n        mAdapter = new TabPagerAdapter(getSupportFragmentManager());\n        mViewPager = (ViewPager) findViewById(R.id.myviewpager);\n\n        //讲ViewPager和Adapter绑定起来获得数据\n        mViewPager.setAdapter(mAdapter);\n\n        //一站式同步，将TabLayout和PagerAdapter绑定起来\n        mTabLayout.setupWithViewPager(mViewPager);\n\n```\n\nPagerAdapter的定义可以去查看官方文档。需要实现两个方法。一个是**getItem**方法，用来根据position返回不同的Fragment。getCount方法用来返回标签的个数，而getPagerTitle方法可以获得页面对应的标签。代码把这些定义好就可以成功了。\n\n### 抽屉效果的实现\n首先得在xml定义一个 **DrawerLayout** ，然后第一个子节点是本体要显示的内容maincontent，然后之后放入一个**NavigationView**来做Menu。\n``` java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\"\n    android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\n    android:fitsSystemWindows=\"true\" tools:openDrawer=\"start\">\n\n    <include layout=\"@layout/activity_main\" android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\" />\n\n    <android.support.design.widget.NavigationView android:id=\"@+id/nav_view\"\n        android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\"\n        android:layout_gravity=\"start\" android:fitsSystemWindows=\"true\"\n        app:menu=\"@menu/activity_main_drawer_drawer\" />\n\n</android.support.v4.widget.DrawerLayout>\n```\n\n定义一个drawerlayout布局文件，然后最后在Activity里面调用就可以了。\n\n\n抽屉效果的实现也是不难的，我们只需要使用DrawerLayout这一个布局。首先我们定义一个drawer的xml文件，然后这里要注意，第一个放的子节点必须是你要放的主要界面，即是刚才的activity_main.xml。所以我们现在假定有以下的布局。\n\n``` java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\"\n    android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\n    android:fitsSystemWindows=\"true\" tools:openDrawer=\"start\">\n\n    <include layout=\"@layout/activity_main\" android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\" />\n\n    <android.support.design.widget.NavigationView android:id=\"@+id/nav_view\"\n        android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\"\n        android:layout_gravity=\"start\" android:fitsSystemWindows=\"true\"\n        app:menu=\"@menu/activity_main_drawer_menu\" />\n\n</android.support.v4.widget.DrawerLayout>\n```\n\n这时我们要在res下开个menu文件夹，创建menu条目xml来创建对应的菜单。例如：\n\n``` java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n    <group android:checkableBehavior=\"single\">\n        <item\n            android:id=\"@+id/animation\"\n            android:title=\"动画\" />\n        <item\n            android:id=\"@+id/book\"\n            android:title=\"书籍\" />\n        <item\n            android:id=\"@+id/music\"\n            android:title=\"音乐\" />\n        <item\n            android:id=\"@+id/game\"\n            android:title=\"游戏\" />\n    </group>\n</menu>\n```\n\n当然你也可以给每个条目添加icon，然后还要给NavigationView定制一个header，header也是个xml文件，这里就不给出header文件了。然后在代码中指定就形成一个初步的Drawer了。\n\n``` java\nmNavigationView = (NavigationView) findViewById(R.id.nav_view);\n        View nav_header = mNavigationView.inflateHeaderView(R.layout.nav_header);\n```\n\n\n","source":"_posts/project_learning.md","raw":"---\ntitle: 安卓实战学习记录01\ndate: 2016-03-20 23:28:52\ntags: \n - Android \r\ncategories: Android\n---\n\n---\n\n## 顶部导航和左右滑动抽屉\n\n#### Toolbar\n\n跟导航栏有关则有**Actionbar**和**Toolbar** 查阅资料可知，Toolbar是在API21后引进的，放在v7库当中，是应用的内容标准工具栏，而**Actionbar**一些方法已经标注过时了。相比于**Actionbar**，它变得更加自由。\n\n使用Toolbar要先把主题样式里的Actionbar去掉，在manifest中\n\n    android:theme=\"@style/Theme.AppCompat.Light.NoActionBar\">\n\n\n此外toolbar 是没有tab的，他需要结合support库里的tablayout来完成原来actionbar里的tab功能。除此之外，你在使用toolbar的时候要先屏蔽掉\n\n定义好xml文件后，我们在java文件中引入toolbar这个类\n\n``` java\nprivate android.support.v7.widget.Toolbar toolbar;\n```\n\n这里注意要引用supportv7的包，否则会出错，Toolbar向下兼容，这样才可以接着调用**setSupportActionBar**\n\n\n``` java\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    oolbar = (android.support.v7.widget.Toolbar) findViewById(R.id.mytoolbar);\n    setSupportActionBar(toolbar);\n    }\n\n```\n\ntoolbar很灵活，因为它就是一个viewgroup。如果要显示navigationicon，也许最好的做法是把它在代码中进行set，因为xml中的设置可能要API21以上才能看见\n\n\n#### DrawerLayout\n官方在13年发布的一个布局，用以创建侧滑菜单。从此我们可以不需要使用github上的侧滑菜单项目了。要创建一个DrawerLayout，我们必须要把它定为根视图，这样再把主要视图作为第一个子节点放入\n\n\n#### CoordinatorLayout\n\n根据谷歌的官方文档\n>CoordinatorLayout is a super-powered FrameLayout.\n\n可以看到它真是super-powered\nCoordinatorLayout一般用于顶层布局和协调子布局。\n要使用它必须在Gradle把包引进来。\n\n``` java\ncompile 'com.android.support:design:23.1.1' \n```\n由于CoordinatorLayout基于FrameLayout，所以这里也提一下FrameLayout，并且再提一下待会用到的几个layout\n##### FrameLayout\n\n帧布局FrameLayout在Android的五大布局中是最简单的布局方式，在需要布局中的控件有重叠的情况下才使用。FrameLayout中的控件layout\\_margin设置要依赖layout\\_gravity属性，否则layout_margin设置无效。如果想要控件正常显示，可以将控件的layout\\_gravity设置为top,以屏幕左上角为参考点。\n\n\n##### AppBarLayout\n>AppBarLayout is a vertical LinearLayout which implements many of the features of material designs app bar concept, namely scrolling gestures.\n\n经常用来实现一线滑动效果并且经常和CoordinatorLayout配套使用\n\n##### TabLayout\n这也是谷歌推出的新控件，可以很方便的用来作标签导航。结合ViewPager一起使用能有很好的效果。\n\n### 标签页的具体实现\n\n标签页的主角毫无疑问就是TabLayout了。我们现在xml文件中定义TabLayout。\n\n\n``` java\n<android.support.design.widget.TabLayout\n   android:id=\"@+id/tabs\"\n   android:layout_width=\"match_parent\"\n   ndroid:layout_height=\"wrap_content\">\n\n```\n\n定义了之后就已经可以标签名之类的属性了。但是我们的目的是标签分页实现之后跳转到不同的Fragment。所以我们还得使用一个ViewPager跟TabLayout配套使用。要使得标签跳转，可以直接用**FragmentPagerAdapter** 跟TabLayout配套使用。这样这个Adapter就同时控制了TabLayout和ViewPager并使他们数据同步。\n``` java\n        <android.support.v4.view.ViewPager\n            android:id=\"@+id/myviewpager\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\">\n\n        </android.support.v4.view.ViewPager>\n```\n\n接下来是代码部分了\n``` java\n        TabLayout mTabLayout = (TabLayout) findViewById(R.id.tabs);\n\n        //取得一个自定义PagerAdapter的实例\n        mAdapter = new TabPagerAdapter(getSupportFragmentManager());\n        mViewPager = (ViewPager) findViewById(R.id.myviewpager);\n\n        //讲ViewPager和Adapter绑定起来获得数据\n        mViewPager.setAdapter(mAdapter);\n\n        //一站式同步，将TabLayout和PagerAdapter绑定起来\n        mTabLayout.setupWithViewPager(mViewPager);\n\n```\n\nPagerAdapter的定义可以去查看官方文档。需要实现两个方法。一个是**getItem**方法，用来根据position返回不同的Fragment。getCount方法用来返回标签的个数，而getPagerTitle方法可以获得页面对应的标签。代码把这些定义好就可以成功了。\n\n### 抽屉效果的实现\n首先得在xml定义一个 **DrawerLayout** ，然后第一个子节点是本体要显示的内容maincontent，然后之后放入一个**NavigationView**来做Menu。\n``` java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\"\n    android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\n    android:fitsSystemWindows=\"true\" tools:openDrawer=\"start\">\n\n    <include layout=\"@layout/activity_main\" android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\" />\n\n    <android.support.design.widget.NavigationView android:id=\"@+id/nav_view\"\n        android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\"\n        android:layout_gravity=\"start\" android:fitsSystemWindows=\"true\"\n        app:menu=\"@menu/activity_main_drawer_drawer\" />\n\n</android.support.v4.widget.DrawerLayout>\n```\n\n定义一个drawerlayout布局文件，然后最后在Activity里面调用就可以了。\n\n\n抽屉效果的实现也是不难的，我们只需要使用DrawerLayout这一个布局。首先我们定义一个drawer的xml文件，然后这里要注意，第一个放的子节点必须是你要放的主要界面，即是刚才的activity_main.xml。所以我们现在假定有以下的布局。\n\n``` java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\"\n    android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\n    android:fitsSystemWindows=\"true\" tools:openDrawer=\"start\">\n\n    <include layout=\"@layout/activity_main\" android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\" />\n\n    <android.support.design.widget.NavigationView android:id=\"@+id/nav_view\"\n        android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\"\n        android:layout_gravity=\"start\" android:fitsSystemWindows=\"true\"\n        app:menu=\"@menu/activity_main_drawer_menu\" />\n\n</android.support.v4.widget.DrawerLayout>\n```\n\n这时我们要在res下开个menu文件夹，创建menu条目xml来创建对应的菜单。例如：\n\n``` java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n    <group android:checkableBehavior=\"single\">\n        <item\n            android:id=\"@+id/animation\"\n            android:title=\"动画\" />\n        <item\n            android:id=\"@+id/book\"\n            android:title=\"书籍\" />\n        <item\n            android:id=\"@+id/music\"\n            android:title=\"音乐\" />\n        <item\n            android:id=\"@+id/game\"\n            android:title=\"游戏\" />\n    </group>\n</menu>\n```\n\n当然你也可以给每个条目添加icon，然后还要给NavigationView定制一个header，header也是个xml文件，这里就不给出header文件了。然后在代码中指定就形成一个初步的Drawer了。\n\n``` java\nmNavigationView = (NavigationView) findViewById(R.id.nav_view);\n        View nav_header = mNavigationView.inflateHeaderView(R.layout.nav_header);\n```\n\n\n","slug":"project_learning","published":1,"updated":"2016-03-21T16:02:49.815Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cindau1xp001p30xgmlca0kud","content":"<hr>\n<h2 id=\"顶部导航和左右滑动抽屉\"><a href=\"#顶部导航和左右滑动抽屉\" class=\"headerlink\" title=\"顶部导航和左右滑动抽屉\"></a>顶部导航和左右滑动抽屉</h2><h4 id=\"Toolbar\"><a href=\"#Toolbar\" class=\"headerlink\" title=\"Toolbar\"></a>Toolbar</h4><p>跟导航栏有关则有<strong>Actionbar</strong>和<strong>Toolbar</strong> 查阅资料可知，Toolbar是在API21后引进的，放在v7库当中，是应用的内容标准工具栏，而<strong>Actionbar</strong>一些方法已经标注过时了。相比于<strong>Actionbar</strong>，它变得更加自由。</p>\n<p>使用Toolbar要先把主题样式里的Actionbar去掉，在manifest中</p>\n<pre><code>android:theme=&quot;@style/Theme.AppCompat.Light.NoActionBar&quot;&gt;\n</code></pre><p>此外toolbar 是没有tab的，他需要结合support库里的tablayout来完成原来actionbar里的tab功能。除此之外，你在使用toolbar的时候要先屏蔽掉</p>\n<p>定义好xml文件后，我们在java文件中引入toolbar这个类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> android.support.v7.widget.Toolbar toolbar;</span><br></pre></td></tr></table></figure>\n<p>这里注意要引用supportv7的包，否则会出错，Toolbar向下兼容，这样才可以接着调用<strong>setSupportActionBar</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    setContentView(R.layout.activity_main);</span><br><span class=\"line\">    oolbar = (android.support.v7.widget.Toolbar) findViewById(R.id.mytoolbar);</span><br><span class=\"line\">    setSupportActionBar(toolbar);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>toolbar很灵活，因为它就是一个viewgroup。如果要显示navigationicon，也许最好的做法是把它在代码中进行set，因为xml中的设置可能要API21以上才能看见</p>\n<h4 id=\"DrawerLayout\"><a href=\"#DrawerLayout\" class=\"headerlink\" title=\"DrawerLayout\"></a>DrawerLayout</h4><p>官方在13年发布的一个布局，用以创建侧滑菜单。从此我们可以不需要使用github上的侧滑菜单项目了。要创建一个DrawerLayout，我们必须要把它定为根视图，这样再把主要视图作为第一个子节点放入</p>\n<h4 id=\"CoordinatorLayout\"><a href=\"#CoordinatorLayout\" class=\"headerlink\" title=\"CoordinatorLayout\"></a>CoordinatorLayout</h4><p>根据谷歌的官方文档</p>\n<blockquote>\n<p>CoordinatorLayout is a super-powered FrameLayout.</p>\n</blockquote>\n<p>可以看到它真是super-powered<br>CoordinatorLayout一般用于顶层布局和协调子布局。<br>要使用它必须在Gradle把包引进来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile <span class=\"string\">'com.android.support:design:23.1.1'</span></span><br></pre></td></tr></table></figure>\n<p>由于CoordinatorLayout基于FrameLayout，所以这里也提一下FrameLayout，并且再提一下待会用到的几个layout</p>\n<h5 id=\"FrameLayout\"><a href=\"#FrameLayout\" class=\"headerlink\" title=\"FrameLayout\"></a>FrameLayout</h5><p>帧布局FrameLayout在Android的五大布局中是最简单的布局方式，在需要布局中的控件有重叠的情况下才使用。FrameLayout中的控件layout_margin设置要依赖layout_gravity属性，否则layout_margin设置无效。如果想要控件正常显示，可以将控件的layout_gravity设置为top,以屏幕左上角为参考点。</p>\n<h5 id=\"AppBarLayout\"><a href=\"#AppBarLayout\" class=\"headerlink\" title=\"AppBarLayout\"></a>AppBarLayout</h5><blockquote>\n<p>AppBarLayout is a vertical LinearLayout which implements many of the features of material designs app bar concept, namely scrolling gestures.</p>\n</blockquote>\n<p>经常用来实现一线滑动效果并且经常和CoordinatorLayout配套使用</p>\n<h5 id=\"TabLayout\"><a href=\"#TabLayout\" class=\"headerlink\" title=\"TabLayout\"></a>TabLayout</h5><p>这也是谷歌推出的新控件，可以很方便的用来作标签导航。结合ViewPager一起使用能有很好的效果。</p>\n<h3 id=\"标签页的具体实现\"><a href=\"#标签页的具体实现\" class=\"headerlink\" title=\"标签页的具体实现\"></a>标签页的具体实现</h3><p>标签页的主角毫无疑问就是TabLayout了。我们现在xml文件中定义TabLayout。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;android.support.design.widget.TabLayout</span><br><span class=\"line\">   android:id=<span class=\"string\">\"@+id/tabs\"</span></span><br><span class=\"line\">   android:layout_width=<span class=\"string\">\"match_parent\"</span></span><br><span class=\"line\">   ndroid:layout_height=<span class=\"string\">\"wrap_content\"</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>定义了之后就已经可以标签名之类的属性了。但是我们的目的是标签分页实现之后跳转到不同的Fragment。所以我们还得使用一个ViewPager跟TabLayout配套使用。要使得标签跳转，可以直接用<strong>FragmentPagerAdapter</strong> 跟TabLayout配套使用。这样这个Adapter就同时控制了TabLayout和ViewPager并使他们数据同步。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;android.support.v4.view.ViewPager</span><br><span class=\"line\">    android:id=\"@+id/myviewpager\"</span><br><span class=\"line\">    android:layout_width=\"match_parent\"</span><br><span class=\"line\">    android:layout_height=\"match_parent\"&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/android.support.v4.view.ViewPager&gt;</span><br></pre></td></tr></table></figure></p>\n<p>接下来是代码部分了<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TabLayout mTabLayout = (TabLayout) findViewById(R.id.tabs);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//取得一个自定义PagerAdapter的实例</span></span><br><span class=\"line\">mAdapter = <span class=\"keyword\">new</span> TabPagerAdapter(getSupportFragmentManager());</span><br><span class=\"line\">mViewPager = (ViewPager) findViewById(R.id.myviewpager);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//讲ViewPager和Adapter绑定起来获得数据</span></span><br><span class=\"line\">mViewPager.setAdapter(mAdapter);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一站式同步，将TabLayout和PagerAdapter绑定起来</span></span><br><span class=\"line\">mTabLayout.setupWithViewPager(mViewPager);</span><br></pre></td></tr></table></figure></p>\n<p>PagerAdapter的定义可以去查看官方文档。需要实现两个方法。一个是<strong>getItem</strong>方法，用来根据position返回不同的Fragment。getCount方法用来返回标签的个数，而getPagerTitle方法可以获得页面对应的标签。代码把这些定义好就可以成功了。</p>\n<h3 id=\"抽屉效果的实现\"><a href=\"#抽屉效果的实现\" class=\"headerlink\" title=\"抽屉效果的实现\"></a>抽屉效果的实现</h3><p>首先得在xml定义一个 <strong>DrawerLayout</strong> ，然后第一个子节点是本体要显示的内容maincontent，然后之后放入一个<strong>NavigationView</strong>来做Menu。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span><br><span class=\"line\">&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"</span><br><span class=\"line\">    xmlns:app=\"http://schemas.android.com/apk/res-auto\"</span><br><span class=\"line\">    xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\"</span><br><span class=\"line\">    android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"</span><br><span class=\"line\">    android:fitsSystemWindows=\"true\" tools:openDrawer=\"start\"&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;include layout=\"@layout/activity_main\" android:layout_width=\"match_parent\"</span><br><span class=\"line\">        android:layout_height=\"match_parent\" /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;android.support.design.widget.NavigationView android:id=\"@+id/nav_view\"</span><br><span class=\"line\">        android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\"</span><br><span class=\"line\">        android:layout_gravity=\"start\" android:fitsSystemWindows=\"true\"</span><br><span class=\"line\">        app:menu=\"@menu/activity_main_drawer_drawer\" /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/android.support.v4.widget.DrawerLayout&gt;</span><br></pre></td></tr></table></figure></p>\n<p>定义一个drawerlayout布局文件，然后最后在Activity里面调用就可以了。</p>\n<p>抽屉效果的实现也是不难的，我们只需要使用DrawerLayout这一个布局。首先我们定义一个drawer的xml文件，然后这里要注意，第一个放的子节点必须是你要放的主要界面，即是刚才的activity_main.xml。所以我们现在假定有以下的布局。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span><br><span class=\"line\">&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"</span><br><span class=\"line\">    xmlns:app=\"http://schemas.android.com/apk/res-auto\"</span><br><span class=\"line\">    xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\"</span><br><span class=\"line\">    android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"</span><br><span class=\"line\">    android:fitsSystemWindows=\"true\" tools:openDrawer=\"start\"&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;include layout=\"@layout/activity_main\" android:layout_width=\"match_parent\"</span><br><span class=\"line\">        android:layout_height=\"match_parent\" /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;android.support.design.widget.NavigationView android:id=\"@+id/nav_view\"</span><br><span class=\"line\">        android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\"</span><br><span class=\"line\">        android:layout_gravity=\"start\" android:fitsSystemWindows=\"true\"</span><br><span class=\"line\">        app:menu=\"@menu/activity_main_drawer_menu\" /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/android.support.v4.widget.DrawerLayout&gt;</span><br></pre></td></tr></table></figure>\n<p>这时我们要在res下开个menu文件夹，创建menu条目xml来创建对应的菜单。例如：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span><br><span class=\"line\">&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;group android:checkableBehavior=\"single\"&gt;</span><br><span class=\"line\">        &lt;item</span><br><span class=\"line\">            android:id=\"@+id/animation\"</span><br><span class=\"line\">            android:title=\"动画\" /&gt;</span><br><span class=\"line\">        &lt;item</span><br><span class=\"line\">            android:id=\"@+id/book\"</span><br><span class=\"line\">            android:title=\"书籍\" /&gt;</span><br><span class=\"line\">        &lt;item</span><br><span class=\"line\">            android:id=\"@+id/music\"</span><br><span class=\"line\">            android:title=\"音乐\" /&gt;</span><br><span class=\"line\">        &lt;item</span><br><span class=\"line\">            android:id=\"@+id/game\"</span><br><span class=\"line\">            android:title=\"游戏\" /&gt;</span><br><span class=\"line\">    &lt;/group&gt;</span><br><span class=\"line\">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>\n<p>当然你也可以给每个条目添加icon，然后还要给NavigationView定制一个header，header也是个xml文件，这里就不给出header文件了。然后在代码中指定就形成一个初步的Drawer了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mNavigationView = (NavigationView) findViewById(R.id.nav_view);</span><br><span class=\"line\">        View nav_header = mNavigationView.inflateHeaderView(R.layout.nav_header);</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<hr>\n<h2 id=\"顶部导航和左右滑动抽屉\"><a href=\"#顶部导航和左右滑动抽屉\" class=\"headerlink\" title=\"顶部导航和左右滑动抽屉\"></a>顶部导航和左右滑动抽屉</h2><h4 id=\"Toolbar\"><a href=\"#Toolbar\" class=\"headerlink\" title=\"Toolbar\"></a>Toolbar</h4><p>跟导航栏有关则有<strong>Actionbar</strong>和<strong>Toolbar</strong> 查阅资料可知，Toolbar是在API21后引进的，放在v7库当中，是应用的内容标准工具栏，而<strong>Actionbar</strong>一些方法已经标注过时了。相比于<strong>Actionbar</strong>，它变得更加自由。</p>\n<p>使用Toolbar要先把主题样式里的Actionbar去掉，在manifest中</p>\n<pre><code>android:theme=&quot;@style/Theme.AppCompat.Light.NoActionBar&quot;&gt;\n</code></pre><p>此外toolbar 是没有tab的，他需要结合support库里的tablayout来完成原来actionbar里的tab功能。除此之外，你在使用toolbar的时候要先屏蔽掉</p>\n<p>定义好xml文件后，我们在java文件中引入toolbar这个类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> android.support.v7.widget.Toolbar toolbar;</span><br></pre></td></tr></table></figure>\n<p>这里注意要引用supportv7的包，否则会出错，Toolbar向下兼容，这样才可以接着调用<strong>setSupportActionBar</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    setContentView(R.layout.activity_main);</span><br><span class=\"line\">    oolbar = (android.support.v7.widget.Toolbar) findViewById(R.id.mytoolbar);</span><br><span class=\"line\">    setSupportActionBar(toolbar);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>toolbar很灵活，因为它就是一个viewgroup。如果要显示navigationicon，也许最好的做法是把它在代码中进行set，因为xml中的设置可能要API21以上才能看见</p>\n<h4 id=\"DrawerLayout\"><a href=\"#DrawerLayout\" class=\"headerlink\" title=\"DrawerLayout\"></a>DrawerLayout</h4><p>官方在13年发布的一个布局，用以创建侧滑菜单。从此我们可以不需要使用github上的侧滑菜单项目了。要创建一个DrawerLayout，我们必须要把它定为根视图，这样再把主要视图作为第一个子节点放入</p>\n<h4 id=\"CoordinatorLayout\"><a href=\"#CoordinatorLayout\" class=\"headerlink\" title=\"CoordinatorLayout\"></a>CoordinatorLayout</h4><p>根据谷歌的官方文档</p>\n<blockquote>\n<p>CoordinatorLayout is a super-powered FrameLayout.</p>\n</blockquote>\n<p>可以看到它真是super-powered<br>CoordinatorLayout一般用于顶层布局和协调子布局。<br>要使用它必须在Gradle把包引进来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile <span class=\"string\">'com.android.support:design:23.1.1'</span></span><br></pre></td></tr></table></figure>\n<p>由于CoordinatorLayout基于FrameLayout，所以这里也提一下FrameLayout，并且再提一下待会用到的几个layout</p>\n<h5 id=\"FrameLayout\"><a href=\"#FrameLayout\" class=\"headerlink\" title=\"FrameLayout\"></a>FrameLayout</h5><p>帧布局FrameLayout在Android的五大布局中是最简单的布局方式，在需要布局中的控件有重叠的情况下才使用。FrameLayout中的控件layout_margin设置要依赖layout_gravity属性，否则layout_margin设置无效。如果想要控件正常显示，可以将控件的layout_gravity设置为top,以屏幕左上角为参考点。</p>\n<h5 id=\"AppBarLayout\"><a href=\"#AppBarLayout\" class=\"headerlink\" title=\"AppBarLayout\"></a>AppBarLayout</h5><blockquote>\n<p>AppBarLayout is a vertical LinearLayout which implements many of the features of material designs app bar concept, namely scrolling gestures.</p>\n</blockquote>\n<p>经常用来实现一线滑动效果并且经常和CoordinatorLayout配套使用</p>\n<h5 id=\"TabLayout\"><a href=\"#TabLayout\" class=\"headerlink\" title=\"TabLayout\"></a>TabLayout</h5><p>这也是谷歌推出的新控件，可以很方便的用来作标签导航。结合ViewPager一起使用能有很好的效果。</p>\n<h3 id=\"标签页的具体实现\"><a href=\"#标签页的具体实现\" class=\"headerlink\" title=\"标签页的具体实现\"></a>标签页的具体实现</h3><p>标签页的主角毫无疑问就是TabLayout了。我们现在xml文件中定义TabLayout。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;android.support.design.widget.TabLayout</span><br><span class=\"line\">   android:id=<span class=\"string\">\"@+id/tabs\"</span></span><br><span class=\"line\">   android:layout_width=<span class=\"string\">\"match_parent\"</span></span><br><span class=\"line\">   ndroid:layout_height=<span class=\"string\">\"wrap_content\"</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>定义了之后就已经可以标签名之类的属性了。但是我们的目的是标签分页实现之后跳转到不同的Fragment。所以我们还得使用一个ViewPager跟TabLayout配套使用。要使得标签跳转，可以直接用<strong>FragmentPagerAdapter</strong> 跟TabLayout配套使用。这样这个Adapter就同时控制了TabLayout和ViewPager并使他们数据同步。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;android.support.v4.view.ViewPager</span><br><span class=\"line\">    android:id=\"@+id/myviewpager\"</span><br><span class=\"line\">    android:layout_width=\"match_parent\"</span><br><span class=\"line\">    android:layout_height=\"match_parent\"&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/android.support.v4.view.ViewPager&gt;</span><br></pre></td></tr></table></figure></p>\n<p>接下来是代码部分了<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TabLayout mTabLayout = (TabLayout) findViewById(R.id.tabs);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//取得一个自定义PagerAdapter的实例</span></span><br><span class=\"line\">mAdapter = <span class=\"keyword\">new</span> TabPagerAdapter(getSupportFragmentManager());</span><br><span class=\"line\">mViewPager = (ViewPager) findViewById(R.id.myviewpager);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//讲ViewPager和Adapter绑定起来获得数据</span></span><br><span class=\"line\">mViewPager.setAdapter(mAdapter);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一站式同步，将TabLayout和PagerAdapter绑定起来</span></span><br><span class=\"line\">mTabLayout.setupWithViewPager(mViewPager);</span><br></pre></td></tr></table></figure></p>\n<p>PagerAdapter的定义可以去查看官方文档。需要实现两个方法。一个是<strong>getItem</strong>方法，用来根据position返回不同的Fragment。getCount方法用来返回标签的个数，而getPagerTitle方法可以获得页面对应的标签。代码把这些定义好就可以成功了。</p>\n<h3 id=\"抽屉效果的实现\"><a href=\"#抽屉效果的实现\" class=\"headerlink\" title=\"抽屉效果的实现\"></a>抽屉效果的实现</h3><p>首先得在xml定义一个 <strong>DrawerLayout</strong> ，然后第一个子节点是本体要显示的内容maincontent，然后之后放入一个<strong>NavigationView</strong>来做Menu。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span><br><span class=\"line\">&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"</span><br><span class=\"line\">    xmlns:app=\"http://schemas.android.com/apk/res-auto\"</span><br><span class=\"line\">    xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\"</span><br><span class=\"line\">    android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"</span><br><span class=\"line\">    android:fitsSystemWindows=\"true\" tools:openDrawer=\"start\"&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;include layout=\"@layout/activity_main\" android:layout_width=\"match_parent\"</span><br><span class=\"line\">        android:layout_height=\"match_parent\" /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;android.support.design.widget.NavigationView android:id=\"@+id/nav_view\"</span><br><span class=\"line\">        android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\"</span><br><span class=\"line\">        android:layout_gravity=\"start\" android:fitsSystemWindows=\"true\"</span><br><span class=\"line\">        app:menu=\"@menu/activity_main_drawer_drawer\" /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/android.support.v4.widget.DrawerLayout&gt;</span><br></pre></td></tr></table></figure></p>\n<p>定义一个drawerlayout布局文件，然后最后在Activity里面调用就可以了。</p>\n<p>抽屉效果的实现也是不难的，我们只需要使用DrawerLayout这一个布局。首先我们定义一个drawer的xml文件，然后这里要注意，第一个放的子节点必须是你要放的主要界面，即是刚才的activity_main.xml。所以我们现在假定有以下的布局。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span><br><span class=\"line\">&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"</span><br><span class=\"line\">    xmlns:app=\"http://schemas.android.com/apk/res-auto\"</span><br><span class=\"line\">    xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\"</span><br><span class=\"line\">    android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"</span><br><span class=\"line\">    android:fitsSystemWindows=\"true\" tools:openDrawer=\"start\"&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;include layout=\"@layout/activity_main\" android:layout_width=\"match_parent\"</span><br><span class=\"line\">        android:layout_height=\"match_parent\" /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;android.support.design.widget.NavigationView android:id=\"@+id/nav_view\"</span><br><span class=\"line\">        android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\"</span><br><span class=\"line\">        android:layout_gravity=\"start\" android:fitsSystemWindows=\"true\"</span><br><span class=\"line\">        app:menu=\"@menu/activity_main_drawer_menu\" /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/android.support.v4.widget.DrawerLayout&gt;</span><br></pre></td></tr></table></figure>\n<p>这时我们要在res下开个menu文件夹，创建menu条目xml来创建对应的菜单。例如：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span><br><span class=\"line\">&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;group android:checkableBehavior=\"single\"&gt;</span><br><span class=\"line\">        &lt;item</span><br><span class=\"line\">            android:id=\"@+id/animation\"</span><br><span class=\"line\">            android:title=\"动画\" /&gt;</span><br><span class=\"line\">        &lt;item</span><br><span class=\"line\">            android:id=\"@+id/book\"</span><br><span class=\"line\">            android:title=\"书籍\" /&gt;</span><br><span class=\"line\">        &lt;item</span><br><span class=\"line\">            android:id=\"@+id/music\"</span><br><span class=\"line\">            android:title=\"音乐\" /&gt;</span><br><span class=\"line\">        &lt;item</span><br><span class=\"line\">            android:id=\"@+id/game\"</span><br><span class=\"line\">            android:title=\"游戏\" /&gt;</span><br><span class=\"line\">    &lt;/group&gt;</span><br><span class=\"line\">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>\n<p>当然你也可以给每个条目添加icon，然后还要给NavigationView定制一个header，header也是个xml文件，这里就不给出header文件了。然后在代码中指定就形成一个初步的Drawer了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mNavigationView = (NavigationView) findViewById(R.id.nav_view);</span><br><span class=\"line\">        View nav_header = mNavigationView.inflateHeaderView(R.layout.nav_header);</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[{"_id":"source/_posts/20151226-01/Image01.png","slug":"Image01.png","post":"cindau1vk000030xgpdcrpzmi","modified":0,"renderable":0},{"_id":"source/_posts/20160323-01/example.jpg","slug":"example.jpg","post":"cindau1wh000c30xgr6u3j0jk","modified":0,"renderable":0},{"_id":"source/_posts/20160408-01/memory.jpg","slug":"memory.jpg","post":"cindau1wt000m30xgflgmvg7x","modified":0,"renderable":0},{"_id":"source/_posts/20160417-01/command.jpg","slug":"command.jpg","post":"cindau1x4001130xgawppbios","modified":0,"renderable":0},{"_id":"source/_posts/20160423-01/io.png","slug":"io.png","post":"cindau1x9001630xgxjzkgorm","modified":0,"renderable":0},{"_id":"source/_posts/20160418-02/handler.jpg","slug":"handler.jpg","post":"cindau1xg001e30xg8qrt4sw7","modified":0,"renderable":0},{"_id":"source/_posts/20160328-01/java-thread.jpg","slug":"java-thread.jpg","post":"cindau1xi001h30xg4eednt6a","modified":0,"renderable":0},{"_id":"source/_posts/20160415-01/class_life.jpg","slug":"class_life.jpg","post":"cindau1xn001m30xgpa9ulrjg","modified":0,"renderable":0},{"_id":"source/_posts/20160415-01/classloader.jpg","slug":"classloader.jpg","post":"cindau1xn001m30xgpa9ulrjg","modified":0,"renderable":0},{"_id":"source/_posts/20160423-01/buffer.jpg","slug":"buffer.jpg","post":"cindau1x9001630xgxjzkgorm","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cindau1vk000030xgpdcrpzmi","category_id":"cindau1w0000530xgw7zi0u1q","_id":"cindau1wk000e30xgbq7pq7cl"},{"post_id":"cindau1wh000c30xgr6u3j0jk","category_id":"cindau1w0000530xgw7zi0u1q","_id":"cindau1ws000k30xgm7p9i6ag"},{"post_id":"cindau1vu000230xge894hsbc","category_id":"cindau1w0000530xgw7zi0u1q","_id":"cindau1wx000p30xgpekjc3kx"},{"post_id":"cindau1wq000j30xgwh5fbta4","category_id":"cindau1wn000g30xg6jfd9e41","_id":"cindau1wz000s30xg02s6junl"},{"post_id":"cindau1w0000630xg5b15mk3m","category_id":"cindau1wn000g30xg6jfd9e41","_id":"cindau1x2000x30xgwhh0s2mv"},{"post_id":"cindau1wt000m30xgflgmvg7x","category_id":"cindau1wn000g30xg6jfd9e41","_id":"cindau1x4001030xggakg8s2p"},{"post_id":"cindau1wy000r30xgxe9v4lqn","category_id":"cindau1wn000g30xg6jfd9e41","_id":"cindau1x7001530xgjtpd0ma2"},{"post_id":"cindau1w3000830xgkziw0t8m","category_id":"cindau1wn000g30xg6jfd9e41","_id":"cindau1xb001830xg94favhbm"},{"post_id":"cindau1x0000u30xgujjftqze","category_id":"cindau1wn000g30xg6jfd9e41","_id":"cindau1xe001d30xge819eq7r"},{"post_id":"cindau1x2000y30xg1sgatfgi","category_id":"cindau1wn000g30xg6jfd9e41","_id":"cindau1xi001g30xgak3mxpk3"},{"post_id":"cindau1wc000a30xgyujm8m8z","category_id":"cindau1x1000v30xgospaifyz","_id":"cindau1xm001k30xgbud8m42f"},{"post_id":"cindau1wl000f30xgy2rq0oxs","category_id":"cindau1x1000v30xgospaifyz","_id":"cindau1xp001o30xg1ym363kl"},{"post_id":"cindau1xb001930xgov31jf55","category_id":"cindau1wn000g30xg6jfd9e41","_id":"cindau1xu001s30xg628vdf8i"},{"post_id":"cindau1xg001e30xg8qrt4sw7","category_id":"cindau1x1000v30xgospaifyz","_id":"cindau1xv001u30xgrfrrsxe0"},{"post_id":"cindau1x4001130xgawppbios","category_id":"cindau1xe001c30xgx4y9dxny","_id":"cindau1xw001w30xg1sdnm2b3"},{"post_id":"cindau1xi001h30xg4eednt6a","category_id":"cindau1wn000g30xg6jfd9e41","_id":"cindau1xx001z30xgflm34jkb"},{"post_id":"cindau1xn001m30xgpa9ulrjg","category_id":"cindau1wn000g30xg6jfd9e41","_id":"cindau1xy002130xgixmkygkn"},{"post_id":"cindau1xp001p30xgmlca0kud","category_id":"cindau1x1000v30xgospaifyz","_id":"cindau1xz002430xgcve4qaxb"},{"post_id":"cindau1x9001630xgxjzkgorm","category_id":"cindau1xm001l30xgvtc626bs","_id":"cindau1y0002630xgmi5x1t41"}],"PostTag":[{"post_id":"cindau1wc000a30xgyujm8m8z","tag_id":"cindau1vx000430xglgsfzfpt","_id":"cindau1wj000d30xgchoq09fx"},{"post_id":"cindau1vk000030xgpdcrpzmi","tag_id":"cindau1vx000430xglgsfzfpt","_id":"cindau1wp000i30xg4ao4psef"},{"post_id":"cindau1vk000030xgpdcrpzmi","tag_id":"cindau1wa000930xgs571kmb1","_id":"cindau1ws000l30xgnmzw7crf"},{"post_id":"cindau1wl000f30xgy2rq0oxs","tag_id":"cindau1vx000430xglgsfzfpt","_id":"cindau1wx000q30xgwccxn8iz"},{"post_id":"cindau1wq000j30xgwh5fbta4","tag_id":"cindau1wn000h30xgph4x4hy2","_id":"cindau1x0000t30xg538xdjn0"},{"post_id":"cindau1x0000u30xgujjftqze","tag_id":"cindau1wn000h30xgph4x4hy2","_id":"cindau1x4000z30xg2r4i3tjl"},{"post_id":"cindau1x2000y30xg1sgatfgi","tag_id":"cindau1wn000h30xgph4x4hy2","_id":"cindau1x6001330xg86v590z1"},{"post_id":"cindau1vu000230xge894hsbc","tag_id":"cindau1wn000h30xgph4x4hy2","_id":"cindau1xa001730xg05on3389"},{"post_id":"cindau1vu000230xge894hsbc","tag_id":"cindau1vx000430xglgsfzfpt","_id":"cindau1xd001b30xg5jr7259m"},{"post_id":"cindau1vu000230xge894hsbc","tag_id":"cindau1wa000930xgs571kmb1","_id":"cindau1xi001f30xg4p9jr5im"},{"post_id":"cindau1w0000630xg5b15mk3m","tag_id":"cindau1wn000h30xgph4x4hy2","_id":"cindau1xm001j30xg0m0yex1l"},{"post_id":"cindau1xb001930xgov31jf55","tag_id":"cindau1wn000h30xgph4x4hy2","_id":"cindau1xo001n30xgk9kp0piq"},{"post_id":"cindau1xg001e30xg8qrt4sw7","tag_id":"cindau1vx000430xglgsfzfpt","_id":"cindau1xt001q30xg57rp8arr"},{"post_id":"cindau1w3000830xgkziw0t8m","tag_id":"cindau1wn000h30xgph4x4hy2","_id":"cindau1xv001t30xgs30h4q4c"},{"post_id":"cindau1xi001h30xg4eednt6a","tag_id":"cindau1wn000h30xgph4x4hy2","_id":"cindau1xw001v30xgte6aeg4d"},{"post_id":"cindau1wh000c30xgr6u3j0jk","tag_id":"cindau1xl001i30xgxo0nripq","_id":"cindau1xx001y30xg6ztye45n"},{"post_id":"cindau1xp001p30xgmlca0kud","tag_id":"cindau1vx000430xglgsfzfpt","_id":"cindau1xx002030xglpzby18p"},{"post_id":"cindau1wt000m30xgflgmvg7x","tag_id":"cindau1wn000h30xgph4x4hy2","_id":"cindau1xz002330xg8g96rwx7"},{"post_id":"cindau1wt000m30xgflgmvg7x","tag_id":"cindau1xt001r30xghphrp9ft","_id":"cindau1y0002530xgr1pwczug"},{"post_id":"cindau1wy000r30xgxe9v4lqn","tag_id":"cindau1wn000h30xgph4x4hy2","_id":"cindau1y0002830xgv7si0t7k"},{"post_id":"cindau1wy000r30xgxe9v4lqn","tag_id":"cindau1xt001r30xghphrp9ft","_id":"cindau1y1002930xgl1yjnfo6"},{"post_id":"cindau1x4001130xgawppbios","tag_id":"cindau1xy002230xgzt1nf7l5","_id":"cindau1y1002b30xgp8h8qn1l"},{"post_id":"cindau1x9001630xgxjzkgorm","tag_id":"cindau1y0002730xguqgl0zcb","_id":"cindau1y2002c30xg7sy3i1bg"},{"post_id":"cindau1xn001m30xgpa9ulrjg","tag_id":"cindau1wn000h30xgph4x4hy2","_id":"cindau1y2002d30xg7tlwset7"},{"post_id":"cindau1xn001m30xgpa9ulrjg","tag_id":"cindau1xt001r30xghphrp9ft","_id":"cindau1y2002e30xgbz6hkjfp"}],"Tag":[{"name":"Android","_id":"cindau1vx000430xglgsfzfpt"},{"name":"software","_id":"cindau1wa000930xgs571kmb1"},{"name":"java","_id":"cindau1wn000h30xgph4x4hy2"},{"name":"软件使用","_id":"cindau1xl001i30xgxo0nripq"},{"name":"java虚拟机","_id":"cindau1xt001r30xghphrp9ft"},{"name":"设计模式","_id":"cindau1xy002230xgzt1nf7l5"},{"name":"操作系统","_id":"cindau1y0002730xguqgl0zcb"}]}}