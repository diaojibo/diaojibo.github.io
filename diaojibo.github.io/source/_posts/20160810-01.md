---
title: PAT试前准备
date: 2016-08-10 00:50:37
tags: 算法
categories: 算法
---

此博客用于记录准备PAT比赛过程中所复习到的一些经典算法以及一些思考。不定期更新一些思路。

### 找出某两点间所有的最短路径
众所周知，最短路径的经典算法有那几种。比如Floyd算法，dij算法，spfa算法等。其中最为经典的也就算是dij算法了。但是现在有一个需求是需要找出某原点到某目的点的所有最短路径。

而最朴素的dij算法，只能求得单源最短路径的某个值。通过网上查阅论文可以知道，有许多方法可以依据dij算法找出两点间所有最短路径，其中还有构造新图的方法。但是最直接的方法莫过于想办法枚举出所有的最短路径出来的了

当我们需要一条具体最短路径的时候，一版都是在更新最短距离的时候，把每个点的前缀点都记录上，这样从终点就可以一个一个倒推回去，知道哪些点最短时是从哪些点来。同理，如若要求出所有的最短路径，那么最直接的方法就是更新到有相同的最短距离时，把前缀的node记成一个列表，从而把可行的前缀点都记录下来。意思就是，每个点的前缀不再是一个点，而是下拉成一个list，从而最后可以通过dfs找出所有可能性。

``` python
#python算法的具体实现
#常规dij算法上的一些改进
def dij(source,target):
  parent = [[] for i in range(n)]
  isVisited = [False for i in range(n)]
  isVisited[source] = True
  dest = [map[source][i] for i in range(n)]
  dest[source] = 0
  for i in range(n-1):
    min = -1
    for j in range(n):
      if (not isVisited[j]) and (dest[j]!=-1):
        if min==-1 or dest[j]<dest[min]:
          min = j
    isVisited[min] = True
    for j in range(n):
      if map[min][j]!=-1:
        if dest[j] == -1 or dest[min]+map[min][j]<=dest[j]:
          #如果发现更新的距离与现有的最短距离相同,则添加前缀节点
          if dest[j] == dest[min]+map[min][j]:
            #parent添加前缀节点
            parent[j].append(min)
          else:
            #最短路径长度的更新，以前的前缀点都不算数，清空重计
            parent[j] = [min]
          dest[j] = dest[min]+map[min][j]
  return parent,dest[target]


```

### 根据附加信息选择最优最短路
最短路径有很多条的情况下，很多时候需要你从中根据其他附加信息选出一条最短路径出来。之前我有提到，可以通过前缀列表的方式，通过dfs枚举出所有的最短路径来，从而找出附加信息最优的路径。然而这显然是个有点累赘的方法，其实就在dij中，我们就可以通过贪心的方式把这条路径更新出来。

我们已经知道了，当我们有多条最短路径时。Dij算法更新的时候必然会遇到更新值与现在的dist值相等的时候，这时候我们其实无需记录前缀列表的，我们直接判断当前环境下的最优信息是否比原有的好。然后如果更好，就直接更新这个值，再记录下此时的新前缀节点即可。，最后记录下来唯一的前缀路径就是附加信息最优的情况了。这样的话省去我们进行dfs的步骤，省下了时间也减少了代码量。

### 找出一幅图中连通分量的数目
假定一个图有几个区域是不连通的，那么应该如何找出这些区域的数目呢。当然是用dfs或者bfs了，从每一个点开始去遍历，并用一个数组来维护已经遍历过的点，进行了几次dfs就分成了几个区域，这是常规做法。当然很容易我们就能想到并查集，用并查集去求出区域数量的问题。通过状态压缩的并查集，然后求出每个节点有多少个不同的父节点即可，乍看之下，并查集对边表的优势要更大一些，在点多边少的情况下，可以采用遍历边数求并查集的做法。

### 求图中是否存在环
这也是一个相当有意思的问题。接下来分两种情况讨论。
#### 无向图
首先我们要明确一个概念。一个图，假定它的顶点个数为N。

**那么，假若它的边数e>=N,那么这个图必定存在环了。所以如果边数直接就大于等于N，那么无需判断，必定存在环。**

但是如若边长的数量小于N，也未必能说明这个图是没有环的。因为很可能这个图被划分成了若干个连通分量，而这些连通分量中存在环。

如若一个连通的图它不存在环，那么它必定是一棵树，作为一棵树它的边长数必定为N-1(N为此连通图的顶点个数)

所以我们就得到一个解法了。首先，我们通过dfs求出一幅图中所有的连通分量。再分别对这些连通分量判断，如若一个连通分量的边数个数为其顶点个数减一，说明它是一棵树，是合格的。但如果一个连通分量的边数大于等于顶点个数，说明这个连通分量存在环。这就是结合了之前求连通分量解法的一个判断环的方法。

***当然，还有别的方法***

##### 类拓扑排序法
1.先把度数小于等于1的点删去，并把对应点相关的其他点度数减1
2.如果还有度数小于等于1的点，重复步骤1.
3.最后如果还存在无法被删去的点，说明是存在环的。否则没环。

##### dfs算法
遍历过的边不走，最后如果发现有点已经访问过了，则有环。

#### 有向图
有向图求环的方法有两种。

##### 拓扑排序法
其实就是尝试一次拓扑排序。如果对全部点拓扑排序成功说明无环，反之有环。

##### 改进的dfs算法
这个算法挺有意思的。我们如果使用像无向图一样的dfs算法的话显然是行不通的。所以我们设置已访问过的点的状态的时候，不能只用一个bool数组isVisited来标记是否遍历过某点了。

在无向图dfs的基础上，我们把点设置为3个状态。-1 0 1，0说明未遍历过，-1说明这个点已经遍历完了，1说明这个点正在被遍历。如果存在环，那么一个点被重复遍历的时候，它的状态肯定是1，正在被遍历，在深搜的过程中被重复遍历了，说明存在环。0和-1都是没问题的，0的话继续走，-1说明这个点已经**通过其他路线**走过了。

### 不同进制的素数误区
我遇到过这样的情况，就是求不同进制下素数，比如求什么7进制下的素数之类的。一开始看到这个概念有点懵逼，脑子没转过来。但是实际上，素数这个概念也是平台无关的。意思就是说，不管是什么进制下的素数，跟十进制下的素数是一样的，所以转成十进制来求就对了。


### 带权值的汽车加油问题
汽车加油问题是一道很经典的贪心题目。给出加油地点和可携带油的最大数量然后求最少加油次数。这是最典型的贪心。但是把题目稍微改一改又如何呢？

<a>https://www.patest.cn/contests/pat-a-practise/1033</a>


假定给出不同的加油站。每个加油站的油费不一样，车起始的时候无油。求到达终点的时候最少的花费。这样的问题该怎么贪心呢。

起初遇到这题时候，我第一个想法是动规。但是且不说时间效率不达标，由于汽车到达每个加油站时候的所剩油量不一定是整数，这就导致了根据整数来动规的解法是错误的。所以只能老老实实用贪心来解决了。那么怎么贪心呢。

首先我们来假象我们现在处于一个加油站，且油量为0.这时我们必须要加油才能继续往前跑。那么我们应该加多少油呢，答案是可能的范围内加到下一个油费更便宜的加油站为止，而且是刚刚好加到那个加油站。试想一下，如果我们途中在更贵的加油站加油了，那显然还不如在一开始的地方就加好，否则就浪费了不是，而假设我们不在下一个更便宜的地方加油，那继续往前看用的是起点的油费，显然也是更贵。所以我们应该采取的贪心策略是，刚好在极限范围内加到下一个更便宜的加油点，假设更便宜的加油点不存在，就在起点加满然后跑到下一个范围内最便宜的加油站，再来采取同样的策略。流程化之后便是，我如果可以开到下一个更便宜的加油点，把油的数量加到刚好可以开到那里。如果范围内的加油点都更贵，那就加满油开到范围内便宜的地方。

这题给人的启示是，关注数据量和限制时间。增加对贪心算法的敏感度。

### 经典题目记录(一)

#### 数字片段重组

<a>https://www.patest.cn/contests/pat-a-practise/1038</a>

本题出自pat1308，大概意思就是给你一些数字的片段，怎么样重组起来可以使得拼接起来的数字是最小的。比如 01 35 两片段重组，0135显然比3501要小。

起初刚遇到这题也是往贪心的思路去思考。显然字符串排序越小的，越应该排在前面。但是这也有个很致命的问题，比如32和322，哪个应该放在前面呢。如果单纯按照字符串排序，32长度小，是322的前缀，所以应该排前面。然而实际上并非如此。显然0132322是比0132232要大的。那么是322排在前面吗？这时候我就会想，加入接32，如果还有一个片段是1大头或者2大头的，那么这时321X不肯定比322要优吗？

出于这一点，实在是很难决定出顺序。但实际上，这种情况是肯定不会出现的。因为这时仅仅是32 322比较，这种比较的特点是一方是另一方的完全前缀。假设有1打头或者2打头的，肯定会被放到前面接续。不会再出现在这里。**所以这时就横生出一种比较巧妙的排序方法：a+b<b+a**

这种排序方法相当的巧妙，它神奇的把两接续片段的比较长度拉到了一致。通过这种排序就能很好的知道那种片段优先级更高。我很难从具体的理论上解释这种方法的思路，所以这种字符串拼接来排序的方法非常巧妙，也有它的道理，特此记录。

顺便说一说，这题我用dfs最后也跑出来了。dfs剪枝优化的好也是可以做的，并且时间还比排序要短。所以说最后也不能放弃dfs，即便是dfs，剪枝优化以后，也不是没有希望的。代码放在github了。

#### 求1的个数

<a>https://www.patest.cn/contests/pat-a-practise/1049</a>

一道经典问题，给出N。让你求1-N中的所有数字里出现1的个数。一开始做的时候被卡了很久。归纳分析很容易出错。正确的方法便是用归纳的思想每一位每一位的分析。比如1-654中1出现的个数。通过归纳分析每一位，我们都可以知道每一个位上1出现的个数，都跟他前面的位数有关。

(归纳得)
每一位:此位的位数乘以他前面的数字。比如6154，6是千位，前面没数字，所以是0，对于十位5，前面有61所以是61.对于4前面是615所以得615，设现在得到的这个数字为K.得到这个数字以后还没完。再回到那一位的数字本身：小于1 等于1 大于1.小于1则不处理，大于1，则可知这个位置上出现的1的个数是（k+1）乘以位数。如果等于1，则是 K*位数加上后面的数字+1。

举个例子 6154
千位上的1：（0+1）*1000
百位上的1： （6）*100+54+1
十位上的1：（61+1）*10
个位上的1： （615+1）*1
总计 2891

方法是归纳总结出来的，所以说遇到此类题一定要淡定分析方法，寻找规律。