---
title: PAT试前准备
date: 2016-08-10 00:50:37
tags: 算法
categories: 算法
---

此博客用于记录准备PAT比赛过程中所复习到的一些经典算法以及一些思考。不定期更新一些思路。

### 找出某两点间所有的最短路径
众所周知，最短路径的经典算法有那几种。比如Floyd算法，dij算法，spfa算法等。其中最为经典的也就算是dij算法了。但是现在有一个需求是需要找出某原点到某目的点的所有最短路径。

而最朴素的dij算法，只能求得单源最短路径的某个值。通过网上查阅论文可以知道，有许多方法可以依据dij算法找出两点间所有最短路径，其中还有构造新图的方法。但是最直接的方法莫过于想办法枚举出所有的最短路径出来的了

当我们需要一条具体最短路径的时候，一版都是在更新最短距离的时候，把每个点的前缀点都记录上，这样从终点就可以一个一个倒推回去，知道哪些点最短时是从哪些点来。同理，如若要求出所有的最短路径，那么最直接的方法就是更新到有相同的最短距离时，把前缀的node记成一个列表，从而把可行的前缀点都记录下来。意思就是，每个点的前缀不再是一个点，而是下拉成一个list，从而最后可以通过dfs找出所有可能性。

``` python
#python算法的具体实现
#常规dij算法上的一些改进
def dij(source,target):
  parent = [[] for i in range(n)]
  isVisited = [False for i in range(n)]
  isVisited[source] = True
  dest = [map[source][i] for i in range(n)]
  dest[source] = 0
  for i in range(n-1):
    min = -1
    for j in range(n):
      if (not isVisited[j]) and (dest[j]!=-1):
        if min==-1 or dest[j]<dest[min]:
          min = j
    isVisited[min] = True
    for j in range(n):
      if map[min][j]!=-1:
        if dest[j] == -1 or dest[min]+map[min][j]<=dest[j]:
          #如果发现更新的距离与现有的最短距离相同,则添加前缀节点
          if dest[j] == dest[min]+map[min][j]:
            #parent添加前缀节点
            parent[j].append(min)
          else:
            #最短路径长度的更新，以前的前缀点都不算数，清空重计
            parent[j] = [min]
          dest[j] = dest[min]+map[min][j]
  return parent,dest[target]


```