---
title: PAT试前准备
date: 2016-08-10 00:50:37
tags: 算法
categories: 算法
---

此博客用于记录准备PAT比赛过程中所复习到的一些经典算法以及一些思考。不定期更新一些思路。

### 找出某两点间所有的最短路径
众所周知，最短路径的经典算法有那几种。比如Floyd算法，dij算法，spfa算法等。其中最为经典的也就算是dij算法了。但是现在有一个需求是需要找出某原点到某目的点的所有最短路径。

而最朴素的dij算法，只能求得单源最短路径的某个值。通过网上查阅论文可以知道，有许多方法可以依据dij算法找出两点间所有最短路径，其中还有构造新图的方法。但是最直接的方法莫过于想办法枚举出所有的最短路径出来的了

当我们需要一条具体最短路径的时候，一版都是在更新最短距离的时候，把每个点的前缀点都记录上，这样从终点就可以一个一个倒推回去，知道哪些点最短时是从哪些点来。同理，如若要求出所有的最短路径，那么最直接的方法就是更新到有相同的最短距离时，把前缀的node记成一个列表，从而把可行的前缀点都记录下来。意思就是，每个点的前缀不再是一个点，而是下拉成一个list，从而最后可以通过dfs找出所有可能性。

``` python
#python算法的具体实现
#常规dij算法上的一些改进
def dij(source,target):
  parent = [[] for i in range(n)]
  isVisited = [False for i in range(n)]
  isVisited[source] = True
  dest = [map[source][i] for i in range(n)]
  dest[source] = 0
  for i in range(n-1):
    min = -1
    for j in range(n):
      if (not isVisited[j]) and (dest[j]!=-1):
        if min==-1 or dest[j]<dest[min]:
          min = j
    isVisited[min] = True
    for j in range(n):
      if map[min][j]!=-1:
        if dest[j] == -1 or dest[min]+map[min][j]<=dest[j]:
          #如果发现更新的距离与现有的最短距离相同,则添加前缀节点
          if dest[j] == dest[min]+map[min][j]:
            #parent添加前缀节点
            parent[j].append(min)
          else:
            #最短路径长度的更新，以前的前缀点都不算数，清空重计
            parent[j] = [min]
          dest[j] = dest[min]+map[min][j]
  return parent,dest[target]


```

### 根据附加信息选择最优最短路
最短路径有很多条的情况下，很多时候需要你从中根据其他附加信息选出一条最短路径出来。之前我有提到，可以通过前缀列表的方式，通过dfs枚举出所有的最短路径来，从而找出附加信息最优的路径。然而这显然是个有点累赘的方法，其实就在dij中，我们就可以通过贪心的方式把这条路径更新出来。

我们已经知道了，当我们有多条最短路径时。Dij算法更新的时候必然会遇到更新值与现在的dist值相等的时候，这时候我们其实无需记录前缀列表的，我们直接判断当前环境下的最优信息是否比原有的好。然后如果更好，就直接更新这个值，再记录下此时的新前缀节点即可。，最后记录下来唯一的前缀路径就是附加信息最优的情况了。这样的话省去我们进行dfs的步骤，省下了时间也减少了代码量。

###找出一幅图中连通分量的数目
假定一个图有几个区域是不连通的，那么应该如何找出这些区域的数目呢。当然是用dfs或者bfs了，从每一个点开始去遍历，并用一个数组来维护已经遍历过的点，进行了几次dfs就分成了几个区域，这是常规做法。当然很容易我们就能想到并查集，用并查集去求出区域数量的问题。通过状态压缩的并查集，然后求出每个节点有多少个不同的父节点即可，乍看之下，并查集对边表的优势要更大一些，在点多边少的情况下，可以采用遍历边数求并查集的做法。


