---
title: PAT试前准备
date: 2016-08-10 00:50:37
tags: 算法
categories: 算法
---

此博客用于记录准备PAT比赛过程中所复习到的一些经典算法以及一些思考。不定期更新一些思路。

### 找出某两点间所有的最短路径
众所周知，最短路径的经典算法有那几种。比如Floyd算法，dij算法，spfa算法等。其中最为经典的也就算是dij算法了。但是现在有一个需求是需要找出某原点到某目的点的所有最短路径。

而最朴素的dij算法，只能求得单源最短路径的某个值。通过网上查阅论文可以知道，有许多方法可以依据dij算法找出两点间所有最短路径，其中还有构造新图的方法。但是最直接的方法莫过于想办法枚举出所有的最短路径出来的了

当我们需要一条具体最短路径的时候，一版都是在更新最短距离的时候，把每个点的前缀点都记录上，这样从终点就可以一个一个倒推回去，知道哪些点最短时是从哪些点来。同理，如若要求出所有的最短路径，那么最直接的方法就是更新到有相同的最短距离时，把前缀的node记成一个列表，从而把可行的前缀点都记录下来。意思就是，每个点的前缀不再是一个点，而是下拉成一个list，从而最后可以通过dfs找出所有可能性。

``` python
#python算法的具体实现
#常规dij算法上的一些改进
def dij(source,target):
  parent = [[] for i in range(n)]
  isVisited = [False for i in range(n)]
  isVisited[source] = True
  dest = [map[source][i] for i in range(n)]
  dest[source] = 0
  for i in range(n-1):
    min = -1
    for j in range(n):
      if (not isVisited[j]) and (dest[j]!=-1):
        if min==-1 or dest[j]<dest[min]:
          min = j
    isVisited[min] = True
    for j in range(n):
      if map[min][j]!=-1:
        if dest[j] == -1 or dest[min]+map[min][j]<=dest[j]:
          #如果发现更新的距离与现有的最短距离相同,则添加前缀节点
          if dest[j] == dest[min]+map[min][j]:
            #parent添加前缀节点
            parent[j].append(min)
          else:
            #最短路径长度的更新，以前的前缀点都不算数，清空重计
            parent[j] = [min]
          dest[j] = dest[min]+map[min][j]
  return parent,dest[target]


```

### 根据附加信息选择最优最短路
最短路径有很多条的情况下，很多时候需要你从中根据其他附加信息选出一条最短路径出来。之前我有提到，可以通过前缀列表的方式，通过dfs枚举出所有的最短路径来，从而找出附加信息最优的路径。然而这显然是个有点累赘的方法，其实就在dij中，我们就可以通过贪心的方式把这条路径更新出来。

我们已经知道了，当我们有多条最短路径时。Dij算法更新的时候必然会遇到更新值与现在的dist值相等的时候，这时候我们其实无需记录前缀列表的，我们直接判断当前环境下的最优信息是否比原有的好。然后如果更好，就直接更新这个值，再记录下此时的新前缀节点即可。，最后记录下来唯一的前缀路径就是附加信息最优的情况了。这样的话省去我们进行dfs的步骤，省下了时间也减少了代码量。

### 找出一幅图中连通分量的数目
假定一个图有几个区域是不连通的，那么应该如何找出这些区域的数目呢。当然是用dfs或者bfs了，从每一个点开始去遍历，并用一个数组来维护已经遍历过的点，进行了几次dfs就分成了几个区域，这是常规做法。当然很容易我们就能想到并查集，用并查集去求出区域数量的问题。通过状态压缩的并查集，然后求出每个节点有多少个不同的父节点即可，乍看之下，并查集对边表的优势要更大一些，在点多边少的情况下，可以采用遍历边数求并查集的做法。

### 求图中是否存在环
这也是一个相当有意思的问题。接下来分两种情况讨论。
#### 无向图
首先我们要明确一个概念。一个图，假定它的顶点个数为N。

**那么，假若它的边数e>=N,那么这个图必定存在环了。所以如果边数直接就大于等于N，那么无需判断，必定存在环。**

但是如若边长的数量小于N，也未必能说明这个图是没有环的。因为很可能这个图被划分成了若干个连通分量，而这些连通分量中存在环。

如若一个连通的图它不存在环，那么它必定是一棵树，作为一棵树它的边长数必定为N-1(N为此连通图的顶点个数)

所以我们就得到一个解法了。首先，我们通过dfs求出一幅图中所有的连通分量。再分别对这些连通分量判断，如若一个连通分量的边数个数为其顶点个数减一，说明它是一棵树，是合格的。但如果一个连通分量的边数大于等于顶点个数，说明这个连通分量存在环。这就是结合了之前求连通分量解法的一个判断环的方法。

***当然，还有别的方法***

##### 类拓扑排序法
1.先把度数小于等于1的点删去，并把对应点相关的其他点度数减1
2.如果还有度数小于等于1的点，重复步骤1.
3.最后如果还存在无法被删去的点，说明是存在环的。否则没环。

##### dfs算法
遍历过的边不走，最后如果发现有点已经访问过了，则有环。

#### 有向图
有向图求环的方法有两种。

##### 拓扑排序法
其实就是尝试一次拓扑排序。如果对全部点拓扑排序成功说明无环，反之有环。

##### 改进的dfs算法
这个算法挺有意思的。我们如果使用像无向图一样的dfs算法的话显然是行不通的。所以我们设置已访问过的点的状态的时候，不能只用一个bool数组isVisited来标记是否遍历过某点了。

在无向图dfs的基础上，我们把点设置为3个状态。-1 0 1，0说明未遍历过，-1说明这个点已经遍历完了，1说明这个点正在被遍历。如果存在环，那么一个点被重复遍历的时候，它的状态肯定是1，正在被遍历，在深搜的过程中被重复遍历了，说明存在环。0和-1都是没问题的，0的话继续走，-1说明这个点已经**通过其他路线**走过了。

### 不同进制的素数误区
我遇到过这样的情况，就是求不同进制下素数，比如求什么7进制下的素数之类的。一开始看到这个概念有点懵逼，脑子没转过来。但是实际上，素数这个概念也是平台无关的。意思就是说，不管是什么进制下的素数，跟十进制下的素数是一样的，所以转成十进制来求就对了。


