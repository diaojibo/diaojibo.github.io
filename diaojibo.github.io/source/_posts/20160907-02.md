---
title: 树状数组知识点
date: 2016-09-07 23:00:35
tags: 算法
categories: 算法
---

树状数组，是一种用来高效计算数组前缀和，并且动态更新的一种数据结构。支持在O(logn)的时间内查询和动态更新。

### 概念
首先我们知道树状数组跟线段树很像。用来记录数组里一些区间和，它遵循的就是一个规律。 tree[idx]=f[idx-2^r +1]+…+f[idx]。r记为idx的二进制表示中最右边的1后面0的个数

{% asset_img form.png This is an example image %}

{% asset_img form2.png This is an example image %}

上面是从网上节选的图，f数组是原数组。c数组是1-i的和。tree就是我们所说的树状数组。由此可得，树状数组中每一个位置的含义，tree[i]所代表的区间和区域为:从i二进制形式减去最右边的1然后再加1开始直接加到i本身。[i-lowbit(i).....i]

### 构建过程

#### lowbit函数
这个函数用来求二进制形式数中，最右边的1所在位置所代表的数值。
可以经过证明，以下方法可以快速找出最右边的1所在的位置所代表的数值。
比如1100 = 12
在计算机中负数是补码取反加1 
因此 -12 = 0011+1 = 0100
1100 & 0100 = 0100
所以lowbit函数求得最右边置1时的数字为4

``` c++
int lowbit(int x)
{
    return x&(-x);
}
```

#### 构建树状数组

``` c++
void build()
{ 
    for (int i=1;i<=MAX_N;i++)
    {
        BIT[i]=A[i];
        for (int j=i-1; j>i-lowbit(i); j--)
            BIT[i]+=A[j];
    }
}
```

#### 动态更新
假设现在原数组A[i]的值更新了，变化了delta。则所对应覆盖的区域都要加上这个值。
``` c++
void edit(int i, int delta)
{
    for (int j = i; j <= MAX_N; j += lowbit(j))
        BIT[j] += delta;
}
```