---
title: java虚拟机笔记(2) 垃圾回收器与内存分配
date: 2016-04-09 00:34:27
tags: 
 - java
 - java虚拟机
categories: java

---
## 判断对象已死

### 引用计数器算法

比较典型的教科书算法是引用计数算法，每当有地方引用则计数器加一，没有地方引用则计数器减一，清0则被gc回收。

然而实际上并不采用这种方法回收，虽然COM技术，Python这些是用这个方法。但是jvm并没有采用，他很难解决对象之间相互引用的问题。

``` java
public class ref{
  Object instance = null
}

```

好比上面定义的类，如果实例化A和B，A.instance指向B，B的指向A，则最后无法被垃圾回收。所以jvm不采用这种方法

### 可达性算法
类似JAVA C#的主流实现都是采用可达性分析。算法基本思路即是通过一系列“GC ROOTs”对象做为起点搜索，当一个对象到GC Roots没有任何引用链相连时证明此对象不可用。

一个对象要真正被宣告死亡，至少经过两次标记。第一次标记后进行筛选，看是否有必要执行finalize()方法，对象未覆盖此方法或者已经被调用过则视为没有必要执行，否则执行finalize方法。如果被判定为没有必要执行，则进入F-Queue队列等待虚拟机调用自动建立的Finalizer线程执行它。稍后在GC中将对F-Queue中的对象进行第二次标记，第二次标记时它将可能被移出逃脱，如果未能在之前逃脱则基本是要被回收了。

## 垃圾回收算法

### 标记-清除算法
标记出回收对象，标记完成后统一回收。有两个主要不足，一是标记和清除效率都不高，二是容易产生大量不连续内存的碎片。

### 复制算法
将内存分为等大小两块，一块用完了，复制存活对象到另外一块上，清除原来的内存块。但是代价是内存缩小一半

现代虚拟机基本采用这种算法回收新生代，新生代对象朝生夕死，因此可以将内存分为较大的Eden空间和两个较小的Survivor空间，每次使用Eden和其中一块Survivor，讲Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上。默认Eden:Survivor为8:1，虽然每次只有10%的内存被浪费，但是缺点是如果每次的存活对象超过十分之一就不行了。因此Survivor空间不够是要其他内存(老年代)进行分配担保

复制收集算法在对象存活率高时要经常复制，效率会变低

### 标记整理算法
老年代一般采用这种算法，标记完对象后不直接清除，让存活对象向一端移动，然后直接清除边界以外的内存。

## 总结
商业虚拟机都是分代收集，一般是把java堆分成新生代和老年代，这样可以根据各年代特点采用适合的收集算法，每次有大批对象死去的选用复制，存活率高且无额外空间的使用标记清理或者标记整理。

>以上笔记均摘抄自*深入理解java虚拟机-jvm高级特性与最佳实践* 
>
>这是一本非常棒的书，值得一看