---
title: java CAS与一些锁知识的学习
date: 2016-04-18 10:20:11
tags: java
categories: java

---


## CAS
CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。

>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

CAS是一个乐观的操作，如果CAS失败，线程不会立刻被挂起，而是再次尝试或者采取一些更合理的策略(比如什么都不做或者恢复)，这与使用锁的情况不同(获锁失败线程将被挂起)

CAS的实现原理大致如下：

``` java
if (this == expect) {
  this = update
 return true;
} else {
return false;
}

```

这里请注意，代码中的if(this==expect) this=update,这两步操作一起是由硬件实现原子性的，这样就能够实现CAS操作的原子性。

## 有关于的锁知识


### cpu的锁知识
1. 处理器自动保证基本内存操作的原子性
2. 使用总线锁保证原子性，使用处理器提供的一个LOCK#信号，其他处理器的请求将被阻塞住，则原处理器可以独占共享内存。
3. 使用缓存锁保证原子性。因为总线锁开销大，会把其他处理器通往其他内存的通信锁着，所以使用缓存锁，这样也可以保证缓存被独占访问。

### 乐观锁和悲观锁
>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。

## CAS缺点
1. ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。
2. 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。
3. 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。